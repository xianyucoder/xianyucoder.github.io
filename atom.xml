<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咸鱼的博客</title>
  
  <subtitle>You See See You, One Day Day.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xianyucoder.cn/"/>
  <updated>2020-02-28T03:16:10.000Z</updated>
  <id>http://www.xianyucoder.cn/</id>
  
  <author>
    <name>煌金</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解锁服务器新姿势</title>
    <link href="http://www.xianyucoder.cn/2020/02/28/%E8%A7%A3%E9%94%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%B0%E5%A7%BF%E5%8A%BF/"/>
    <id>http://www.xianyucoder.cn/2020/02/28/解锁服务器的新姿势/</id>
    <published>2020-02-28T00:39:35.000Z</published>
    <updated>2020-02-28T03:16:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>记得之前给大家介绍过 如何搭建一个属于自己的 Telegram Bot</p><p>不少朋友都自己上手操作了一番，但是孤零零的一个应用，服务器好像又要落灰了。所以，如何解锁服务器的各种新姿势呢？</p><p>我们先从上次的 Telegram Bot 来讲，上次教大家搭建了这个机器人，除了用来管理自己的频道外，其实还可以用它来监控我们想要购买的商品。【比如口罩】</p><p>这里只要搭配一个特殊的 Python 库就可以实现了。</p><p>目前搭建好的项目提供 X 宝及 X 猫的商品监控功能，使用上，用户可以便捷地发送 App 的分享链接给 Bot 直接进行添加，当商品上架时，用户会连续三次收到来自 Bot 的消息。</p><p>安装 Python 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install python_telegram_bot</span><br></pre></td></tr></table></figure><p>接着参考之前文章中的搭建的 TG Bot ，获取 Token 代入之后的代码即可。</p><p>参考下面现成的项目代码就就可以完成配置了。</p><p><strong>Github : <a href="https://github.com/xiejiangzhao/Ding-Bot" target="_blank" rel="noopener">https://github.com/xiejiangzhao/Ding-Bot</a></strong></p><p>搭建好的项目效果参考下图。</p><p><img src="http://tc.xianyucoder.cn/blog20200226235616.png" alt="效果图"></p><p>除了上面的 TG Bot 监控商品的项目外，只要拥有一台服务器 + 想动手的心，你就可以不停解锁新的姿势。这里简单给大家列举几个：</p><p><strong>搭建一人独享的 TG Bot，从此管理频道不费心。</strong></p><p>【链接】</p><p>搭建一个可以解锁 VIP 音乐的服务，从此听歌不发愁。**</p><p>【链接】</p><p><strong>搭建一个可以同步上传下载的 BT 服务，独享高速下载。</strong></p><p>【链接】</p><p>服务器玩腻了？可以试试大佬们都在玩的 <strong>ModelArts</strong> ，只要鼠标点点点，就可以轻松实现爬虫工程师常用到的拼图验证码缺口识别 API。</p><p><img src="http://tc.xianyucoder.cn/blog20200227093501.png" alt></p><p>再玩玩一站式的 AI 图像识别平台，轻松完成图像深度学习中的图片标注、图片分类预测和模型部署+生成 API。</p><p><img src="http://tc.xianyucoder.cn/blog20200227093613.png" alt></p><p>一站式集成服务，方便快捷，最主要的是这些<strong>黑科技</strong>现在很便宜！！！</p><p>现在<strong>华为开年采购季活动</strong>，购买一台服务器的成本最低 <strong>79元/年</strong>，除此之外，华为云还有数据库专场活动、域名建站专场活动、云安全专场活动。个人用户的各种打折不说，还可以领 <strong>8888</strong> 开年大礼包。</p><p><strong>新用户 2H4G 的云服务器 1.3折</strong>，<strong>老用户</strong>最高可送<strong>2020元优惠券</strong>，云服务器79元用3年。</p><p>我酸了。</p><p>目前我手里的服务器，续费 6 年的有一台，趁着这次活动又搞了一台 3 年期的。</p><p>至少短时间内，写了很久的小玩意儿都可以愉快的跑起来了。</p><p><img src="http://tc.xianyucoder.cn/blog20200227095330.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记得之前给大家介绍过 如何搭建一个属于自己的 Telegram Bot&lt;/p&gt;
&lt;p&gt;不少朋友都自己上手操作了一番，但是孤零零的一个应用，服务器好像又要落灰了。所以，如何解锁服务器的各种新姿势呢？&lt;/p&gt;
&lt;p&gt;我们先从上次的 Telegram Bot 来讲，上次教大家搭建
      
    
    </summary>
    
      <category term="服务器应用" scheme="http://www.xianyucoder.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="服务器应用" scheme="http://www.xianyucoder.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>怼就完事了，总结几种验证码的解决方案</title>
    <link href="http://www.xianyucoder.cn/2020/01/08/%E6%80%BB%E7%BB%93%E5%87%A0%E7%A7%8D%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://www.xianyucoder.cn/2020/01/08/总结几种验证码的解决方案/</id>
    <published>2020-01-08T00:39:35.000Z</published>
    <updated>2020-01-08T07:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>截止到今天咸鱼以及写了很多期关于 Js 逆向的文章了，不过这么多的文章都有一个共通点，都是关于加密参数或者密码加密的解析，很多读者在后台私信希望能够出一些关于滑动验证或者人机验证的分析教程。</p><p>于是咸鱼总结了目前遇到过的的验证码类型以及总结出来的相关处理方式和大家聊一聊。</p><p>现在市面上的验证码的类型大致有下面几种类型。</p><h3 id="图形验证码"><a href="#图形验证码" class="headerlink" title="图形验证码"></a>图形验证码</h3><p>比较常见的英文数字组合成的图形验证码，常常辅以各类干扰线和扭曲图片中的内容达到提高混淆难度的目的，并且通过加长图片中的文字长度提升识别成本。</p><p><img src="http://tc.xianyucoder.cn/blog20200104203024.png" alt="7位英数-难度高"></p><p><img src="http://tc.xianyucoder.cn/blog20200104203424.png" alt="4位英数-难度中等"></p><p><img src="http://tc.xianyucoder.cn/blog20200104203507.png" alt="4位英数-难度低"></p><p>像这类验证码的处理方案有很多种，简单给大家概括一下。</p><p>难度中低的两类验证码，安装 <code>tesserocr</code>，通过 OCR 技术结合 Python 的 <code>tesserocr</code> 库可以就可以完成识别。如果验证码中带有简单干扰线同样可以使用灰度和二值化的方法提高代码的识别率。</p><p>常用示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tesserocr</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">image = Image.open(<span class="string">'code2.jpg'</span>)</span><br><span class="line">image = image.convert(<span class="string">'L'</span>)</span><br><span class="line">threshold = <span class="number">127</span></span><br><span class="line">table = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">if</span> i &lt; threshold:</span><br><span class="line">        table.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        table.append(<span class="number">1</span>)</span><br><span class="line">image = image.point(table, <span class="string">'1'</span>)</span><br><span class="line">result = tesserocr.image_to_text(image)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>难度较高的多位英数+扭曲图形验证码包括上面总结的中低难度的图形验证码，可以通过 Tensorflow 训练的方式达到识别验证码的目的。</p><p>之前我有一个系列文章介绍了整个训练流程，大家可以点击参考。</p><p><a href="https://mp.weixin.qq.com/s/-BfjGC6KZNe2PJ47H85LIQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-BfjGC6KZNe2PJ47H85LIQ</a></p><p><a href="https://mp.weixin.qq.com/s/qVZtKveH8h2BQn2OjsXZYQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qVZtKveH8h2BQn2OjsXZYQ</a></p><p><a href="https://mp.weixin.qq.com/s/AfefH4b5HqNtxTVOjZ-XvA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AfefH4b5HqNtxTVOjZ-XvA</a></p><p>使用这个方式的朋友记得要先准备好足够用的验证码的样本，只要你的模型不是太差，通过足量的样本，不断调优是可以达到一个较为可观的是识别率的。</p><p>目前体验过最好的程序是冷月的四位英数识别成功率高达 99.99% ，不过据知情人透露整个训练的样本达到了 6000 W ，耗费的时间精力可想而知。</p><p>还有一类解决方法是使用打码服务，这个之后再说。</p><h3 id="旋转验证码"><a href="#旋转验证码" class="headerlink" title="旋转验证码"></a>旋转验证码</h3><p>这类验证码是将验证码的图片旋转并且需要用户拖动下方滑块完成将图片摆正的操作才可以完成验证。</p><p><img src="http://tc.xianyucoder.cn/blog20200104213004.png" alt="旋转验证码"></p><p>目前国内市面的服务商还没有一个好的解决方案，不过某家的验证码有一些小小的 bug，依靠劳苦大众的智慧在 GitHub 上我发现了一个很 Nice 的项目。</p><p>项目地址：<a href="https://github.com/scupte/xuanzhaunyanz" target="_blank" rel="noopener">https://github.com/scupte/xuanzhaunyanz</a></p><p>因为图库的容量问题，没有超大的图库作为后盾，将全部的原图抓取下来对比完全可以得到旋转的角度了。</p><p>部分对比代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">imagepath = <span class="string">'9_1.png'</span></span><br><span class="line">img = cv2.imread(imagepath)</span><br><span class="line">gray = cv2.cvtColor ( img , cv2.COLOR_BGR2GRAY )</span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)  </span><br><span class="line">  </span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  </span><br><span class="line"><span class="comment">#cv2.drawContours(img,contours,-1,(0,0,255),1)  </span></span><br><span class="line"><span class="keyword">for</span> cnt <span class="keyword">in</span> contours:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最小外界矩形的宽度和高度</span></span><br><span class="line">    width, height = cv2.minAreaRect(cnt)[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> width* height &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="comment"># 最小的外接矩形</span></span><br><span class="line">        rect = cv2.minAreaRect(cnt)</span><br><span class="line">        box = cv2.boxPoints(rect)  <span class="comment"># 获取最小外接矩形的4个顶点</span></span><br><span class="line">        </span><br><span class="line">        box = np.int0(box)</span><br><span class="line">        <span class="keyword">print</span> box</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> box.ravel():</span><br><span class="line"></span><br><span class="line">            <span class="comment">#绘制最小外界矩形</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                cv2.line(img, tuple(box[i]), tuple(box[(i+<span class="number">1</span>)%<span class="number">4</span>]), <span class="number">0</span>)  <span class="comment"># 5</span></span><br><span class="line">            theta = cv2.minAreaRect(cnt)[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> abs(theta) &lt;= <span class="number">45</span>:</span><br><span class="line">                print(<span class="string">'图片的旋转角度为%s.'</span>%theta)</span><br><span class="line"></span><br><span class="line">             </span><br><span class="line">            <span class="comment">#     angle = theta</span></span><br><span class="line"><span class="keyword">print</span> theta            </span><br><span class="line">cv2.imshow(<span class="string">"img"</span>, img)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="滑动验证码"><a href="#滑动验证码" class="headerlink" title="滑动验证码"></a>滑动验证码</h3><p>说到滑动验证码，一定一定要提某验，虽然说市面上关于滑动验证码的产品有很多，但是某验的地位就像10年前脑白金在保健品市场的地位一样，业界标杆啊。</p><p>不过它越牛逼，市场上用它做防护的网站也越多，像国家企业信用信息公示系统、B 站、狗东等等。</p><p>像某验的解决方案也有很多，不过大同小异。</p><h4 id="selenium-模拟滑动"><a href="#selenium-模拟滑动" class="headerlink" title="selenium 模拟滑动"></a>selenium 模拟滑动</h4><p>使用 selenium 这个大家都听过，步骤大致是将缺口图和原图进行对比获取缺口的横坐标，并使用一定的计算完成轨迹模拟，之后再使用 selenium 滑动完成缺口的拼接。</p><p>这一类方法的优点是门槛低，原理简单，缺点是完成滑动耗时较长，成功率无法估计（同一轨迹计算使用多次后成功率迅速下降）</p><p>常见的轨迹生成代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ease_out_expo</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    曲线函数</span></span><br><span class="line"><span class="string">    :param x:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - pow(<span class="number">2</span>, <span class="number">-10</span> * x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tracks</span><span class="params">(distance, seconds)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    轨迹生成函数</span></span><br><span class="line"><span class="string">    :param distance: 滑动总距离</span></span><br><span class="line"><span class="string">    :param seconds: 滑动总时间</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    tracks = [<span class="number">0</span>]  <span class="comment"># 存放轨迹的数组</span></span><br><span class="line">    offsets = [<span class="number">0</span>]  <span class="comment"># 存放滑动总距离的记录数组</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> np.arange(<span class="number">0.0</span>, seconds, <span class="number">0.1</span>):  <span class="comment"># 产生一个数列如[0.0, 0.1, 0.2, 0.3]</span></span><br><span class="line">        offset = round(ease_out_expo(t/seconds) * distance)  <span class="comment"># 根据时间t计算在曲线上的滑动距离</span></span><br><span class="line">        tracks.append(offset - offsets[<span class="number">-1</span>])  <span class="comment"># 本次计算的距离减去上一次移动的距离，得到本次的轨迹</span></span><br><span class="line">        offsets.append(offset)  <span class="comment"># 至本次滑动了的总距离</span></span><br><span class="line">    <span class="keyword">return</span> offsets, tracks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a, b = get_tracks(<span class="number">138</span>, <span class="number">3</span>)</span><br><span class="line">print(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tracksb</span><span class="params">(distance)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    根据物理的先加速再减速规律计算</span></span><br><span class="line"><span class="string">    :param distance:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    distance += <span class="number">20</span>  <span class="comment"># 加上20是为了滑动超过缺口再回滑</span></span><br><span class="line">    v = <span class="number">0</span>  <span class="comment"># 初速度</span></span><br><span class="line">    t = <span class="number">0.2</span>  <span class="comment"># 以0.2秒为一个计算周期</span></span><br><span class="line">    forward_tracks = []  <span class="comment"># 轨迹记录数组</span></span><br><span class="line">    current = <span class="number">0</span>  <span class="comment"># 初始移动距离</span></span><br><span class="line">    mid = distance * <span class="number">3</span> / <span class="number">5</span>  <span class="comment"># 减速阀值即五分之三的距离加速剩下距离减速</span></span><br><span class="line">    <span class="keyword">while</span> current &lt; distance:  <span class="comment"># 总移动距离等于输入距离时结束</span></span><br><span class="line">        <span class="keyword">if</span> current &lt; mid:  <span class="comment"># 加速状态</span></span><br><span class="line">            a = <span class="number">2</span>  <span class="comment"># 加速度为+2</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 减速状态</span></span><br><span class="line">            a = <span class="number">-3</span>  <span class="comment"># 加速度-3</span></span><br><span class="line">            </span><br><span class="line">        s = v * t + <span class="number">0.5</span> * a * (t ** <span class="number">2</span>)  <span class="comment"># 计算0.2秒周期内的位移</span></span><br><span class="line">        v = v + a * t  <span class="comment"># 计算本次周期后的速度</span></span><br><span class="line">        current += s  <span class="comment"># 将之前移动的总距离，加上本次0.2秒周期内移动的距离</span></span><br><span class="line">        forward_tracks.append(round(s))  <span class="comment"># 记录本次0.2秒周期内的移动距离为轨迹</span></span><br><span class="line"></span><br><span class="line">    back_tracks = [<span class="number">-3</span>, <span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]  <span class="comment"># 手动将开头加上的20，生成减去轨迹，即回滑轨迹</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'forward_tracks'</span>: forward_tracks, <span class="string">'back_tracks'</span>: back_tracks&#125;</span><br></pre></td></tr></table></figure><h4 id="Js-破解关键的参数"><a href="#Js-破解关键的参数" class="headerlink" title="Js 破解关键的参数"></a>Js 破解关键的参数</h4><p>这类方法的门槛就比较高了，通过断点调试 Js，逆向分析滑动后提交的参数的生成逻辑完成参数的生成，之后构造请求完成提交，当然这中间也是需要分析图片的缺口位置与模拟轨迹，不过没有使用到模拟所以速度快成功率高。</p><p>缺点是风险高，代码维护成本高，更新一个新版本就要重新分析而且逆向相关产品的代码是有一定的法律风险的，免费包吃住也不是开玩笑的，所以很多能够商业化的大佬们都闷声发大财不会到处张扬。</p><h4 id="使用现有的服务"><a href="#使用现有的服务" class="headerlink" title="使用现有的服务"></a>使用现有的服务</h4><p>上面两种方法各有各的优缺，很多人就想把这一块的工作量与风险分出去，这就要使用到第三方的服务商了。</p><p>不过目前国内市场上的服务商并没有这类服务，目前咸鱼在使用的是一家俄罗斯的服务商 - 2Captcha</p><p>这个服务商提供的验证码服务有很多种，其中包含了我们比较关心的  GeeTest 。</p><p><img src="http://tc.xianyucoder.cn/blog20200104230400.png" alt="每1000次的价格"></p><p>下面咸鱼给大家简单介绍下如何使用服务。（不要问为啥收费，人家服务商也要吃饭，况且这个价格实在很便宜了）</p><p>首先，注册一个账号，官网是 <a href="http://2captcha.com/zh" target="_blank" rel="noopener">http://2captcha.com/zh</a></p><p><img src="http://tc.xianyucoder.cn/blog20200104230932.png" alt="首页"></p><p>完成注册之后会跳转到控制台界面，这里最重要的是获取到属于你的 API Key 。</p><p><img src="http://tc.xianyucoder.cn/blog20200104231538.png" alt="API KEY"></p><p>好，拿到这个 API Key 之后就可以上手使用服务完成滑动的破解了。</p><p>通过参考官方的 API 文档，我们只需要构建 Get 请求就可以了。</p><p>第一个 Get 请求的组成是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://<span class="number">2</span>captcha.com/<span class="keyword">in</span>.php</span><br><span class="line">?key= 上面获取的API KEY </span><br><span class="line">&amp;method=geetest</span><br><span class="line">&amp;gt= 极验参数</span><br><span class="line">&amp;challenge= 极验参数</span><br><span class="line">&amp;api_server=api-na.geetest.com(可选)</span><br><span class="line">&amp;pageurl= 滑动验证码所在的网页地址</span><br></pre></td></tr></table></figure><p>参数列表：</p><table><thead><tr><th style="text-align:center">参数名</th><th style="text-align:center">参数介绍</th></tr></thead><tbody><tr><td style="text-align:center">key</td><td style="text-align:center">API KEY</td></tr><tr><td style="text-align:center">method</td><td style="text-align:center">表示验证码类型</td></tr><tr><td style="text-align:center">gt</td><td style="text-align:center">极验参数1</td></tr><tr><td style="text-align:center">challenge</td><td style="text-align:center">极验参数2</td></tr><tr><td style="text-align:center">api_server</td><td style="text-align:center">api-na.geetest.com(选填)</td></tr><tr><td style="text-align:center">pageurl</td><td style="text-align:center">滑动验证码所在的网页地址</td></tr></tbody></table><p>这里解释下关于 <code>gt</code> 与 <code>challenge</code> 这两个参数的获取。</p><p>第一个请求中这两个参数其中 <code>gt</code>这个参数是固定的，找一个使用某验的网站就可以获取。例如：</p><p><img src="http://tc.xianyucoder.cn/blog20200104234230.png" alt></p><p><code>challenge</code>这个参数是有一个 Get 请求返回，你找到这个请求之后按照请求重新获取一次，如果是 XHR 的话也可以直接 reply XHR 。</p><p><img src="http://tc.xianyucoder.cn/blog20200104235425.png" alt></p><p>提交完第一个请求之后，会返回类似下面的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OK|<span class="number">2122988149</span> <span class="keyword">or</span> <span class="keyword">as</span> JSON &#123;<span class="string">"status"</span>:<span class="number">1</span>,<span class="string">"request"</span>:<span class="string">"2122988149"</span>&#125;</span><br></pre></td></tr></table></figure><p>这里面的一串数字就是会话 ID。</p><p>有了这个会话 ID 之后我们就可以构建下一个请求了，这中间需要等待一些时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://<span class="number">2</span>captcha.com/res.php</span><br><span class="line">?key=API KEY</span><br><span class="line">&amp;action=get</span><br><span class="line">&amp;id=<span class="number">2122988149</span></span><br></pre></td></tr></table></figure><p>参数列表：</p><table><thead><tr><th style="text-align:center">参数名</th><th style="text-align:center">参数介绍</th></tr></thead><tbody><tr><td style="text-align:center">key</td><td style="text-align:center">API KEY</td></tr><tr><td style="text-align:center">action</td><td style="text-align:center">Get</td></tr><tr><td style="text-align:center">id</td><td style="text-align:center">上一个请求返回的会话ID</td></tr></tbody></table><p>这个请求返回的结果就是我们需要的加密参数了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="string">"challenge"</span>:<span class="string">"1a2b3456cd67890e12345fab678901c2de"</span>,</span><br><span class="line">      <span class="string">"validate"</span>:<span class="string">"09fe8d7c6ba54f32e1dcb0a9fedc8765"</span>,</span><br><span class="line">      <span class="string">"seccode"</span>:<span class="string">"12fe3d4c56789ba01f2e345d6789c012|jordan"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的几类验证码，已经全部介绍完了。</p><p>肯定有有人问像 google 家的 ReCaptcha 以及和他相似的 hCaptcha 的解决方案没有提到啊？</p><p>像以上两类验证码，刚刚提到的服务商也同样有提供接口打码，至于其他的解决方案，目前咸鱼还没有接触过，毕竟这两类验证码，咸鱼手动点击都没办法做到一次通过，目前也只能依赖服务商了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;截止到今天咸鱼以及写了很多期关于 Js 逆向的文章了，不过这么多的文章都有一个共通点，都是关于加密参数或者密码加密的解析，很多读者在后台私信希望能够出一些关于滑动验证或者人机验证的分析教程。&lt;/p&gt;
&lt;p&gt;于是咸鱼总结了目前遇到过的的验证码类型以及总结出来的相关处理方式和大
      
    
    </summary>
    
      <category term="验证码" scheme="http://www.xianyucoder.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
    
      <category term="验证码" scheme="http://www.xianyucoder.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
      <category term="TensorFlow" scheme="http://www.xianyucoder.cn/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向-裁判文书网加密分析20190902版</title>
    <link href="http://www.xianyucoder.cn/2019/09/17/%E6%AF%8F%E6%97%A5JS-%E8%A3%81%E5%88%A4%E6%96%87%E4%B9%A6%E7%BD%91-190902%E7%89%88/"/>
    <id>http://www.xianyucoder.cn/2019/09/17/每日JS-裁判文书网-190902版/</id>
    <published>2019-09-17T10:39:35.000Z</published>
    <updated>2019-09-30T02:02:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="裁判文书网20190902版"><a href="#裁判文书网20190902版" class="headerlink" title="裁判文书网20190902版"></a>裁判文书网20190902版</h4><h5 id="列表页-RequestVerificationToken"><a href="#列表页-RequestVerificationToken" class="headerlink" title="列表页 __RequestVerificationToken"></a>列表页 <code>__RequestVerificationToken</code></h5><p>搜索关键词<code>__RequestVerificationToken</code> 【图1-1】</p><p><img src="http://tc.xianyucoder.cn/blog20190902101008.png" alt="图1-1"></p><p>找到<code>base.random(24)</code>这个方法，这个复制出来就解决了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_random</span>(<span class="params">size</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">""</span>,</span><br><span class="line">        arr = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>, <span class="string">'J'</span>, <span class="string">'K'</span>, <span class="string">'L'</span>, <span class="string">'M'</span>, <span class="string">'N'</span>, <span class="string">'O'</span>, <span class="string">'P'</span>, <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'S'</span>, <span class="string">'T'</span>, <span class="string">'U'</span>, <span class="string">'V'</span>, <span class="string">'W'</span>, <span class="string">'X'</span>, <span class="string">'Y'</span>, <span class="string">'Z'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        str += arr[<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * (arr.length<span class="number">-1</span>))];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ciphertext"><a href="#Ciphertext" class="headerlink" title="Ciphertext"></a>Ciphertext</h4><p>通过XHR断点，查看堆栈信息【图2-1】</p><p><img src="http://tc.xianyucoder.cn/blog20190902105409.png" alt="图2-1"></p><p>加密位置为【图2-2】</p><p><img src="http://tc.xianyucoder.cn/blog20190902105234.png" alt="图2-2"></p><p>直接扣取<code>ciphertext</code>这个方法的代码即可，这里展示部分代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cipher=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span>  <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> timestamp = date.getTime().toString();</span><br><span class="line">    <span class="keyword">var</span> salt =get_random(<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">var</span> year=date.getFullYear().toString();</span><br><span class="line">    <span class="keyword">var</span> month = (date.getMonth()+<span class="number">1</span>&lt;<span class="number">10</span> ? <span class="string">"0"</span>+(date.getMonth()+<span class="number">1</span>) : date.getMonth()).toString();</span><br><span class="line">    <span class="keyword">var</span> day = (date.getDate()&lt;<span class="number">10</span> ? <span class="string">"0"</span>+date.getDate() : date.getDate()).toString();</span><br><span class="line">    <span class="keyword">var</span> iv =year+month+day;</span><br><span class="line">    <span class="keyword">var</span> enc = DES3.encrypt(timestamp,salt,iv).toString();</span><br><span class="line">    <span class="keyword">var</span> str = salt+iv+enc;</span><br><span class="line">    <span class="keyword">var</span> ciphertext = strTobinary(str);</span><br><span class="line">    <span class="keyword">return</span> ciphertext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pageld"><a href="#pageld" class="headerlink" title="pageld"></a>pageld</h4><p>这个参数在首页点击时自动带入，经过测试并不是必须项，可以通过分析首页的源码查看到调用的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_uuid</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> guid = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> n = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">16.0</span>).toString(<span class="number">16</span>);</span><br><span class="line">        guid += n;</span><br><span class="line">        <span class="comment">// if ((i == 8) || (i == 12) || (i == 16) || (i == 20)) guid +=</span></span><br><span class="line">        <span class="comment">// "-";</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> guid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;裁判文书网20190902版&quot;&gt;&lt;a href=&quot;#裁判文书网20190902版&quot; class=&quot;headerlink&quot; title=&quot;裁判文书网20190902版&quot;&gt;&lt;/a&gt;裁判文书网20190902版&lt;/h4&gt;&lt;h5 id=&quot;列表页-RequestVerifi
      
    
    </summary>
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/categories/js%E9%80%86%E5%90%91/"/>
    
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/tags/js%E9%80%86%E5%90%91/"/>
    
      <category term="裁判文书网" scheme="http://www.xianyucoder.cn/tags/%E8%A3%81%E5%88%A4%E6%96%87%E4%B9%A6%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>反反爬-巧破 Cloudflare 5秒盾</title>
    <link href="http://www.xianyucoder.cn/2019/09/16/%E5%8F%8D%E5%8F%8D%E7%88%AC-%E5%B7%A7%E7%A0%B4%20Cloudflare%205%E7%A7%92%E7%9B%BE/"/>
    <id>http://www.xianyucoder.cn/2019/09/16/反反爬-巧破 Cloudflare 5秒盾/</id>
    <published>2019-09-16T10:39:35.000Z</published>
    <updated>2019-09-30T01:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="巧破-Cloudflare-5秒盾"><a href="#巧破-Cloudflare-5秒盾" class="headerlink" title="巧破 Cloudflare 5秒盾"></a>巧破 Cloudflare 5秒盾</h2><p>相信下面这个界面大家都不会陌生。【图1-1】</p><p><img src="http://tc.xianyucoder.cn/blog20190920192205.png" alt="图1-1"></p><p>当我们第一次访问使用 CloudFlare 加速的网站时，网站就会出现让我们等待 5 秒种的提示，当我们需要的通过爬虫爬取这类网站的时候，应该如何爬取呢？</p><h3 id="分析请求"><a href="#分析请求" class="headerlink" title="分析请求"></a>分析请求</h3><p>首先我们需要分析在这个等待的时间里浏览器做了哪些操作。</p><p>通过抓包，我们可以看到在等待的过程中，浏览器做了下面的三次请求【图1-2】- 【图1-4】：</p><p>【图1-2】请求 1 写入 cookie 字段 <code>__cfduid</code> </p><p><img src="http://tc.xianyucoder.cn/blog20190920193036.png" alt="图1-2"></p><p>【图1-3】请求 2 带有疑似加密的请求参数请求并写入 cookie 字段 <code>cf_clearance</code></p><p><img src="http://tc.xianyucoder.cn/blog20190920193527.png" alt="图1-3"></p><p>【图1-4】请求 3 带上前面写入的<code>cookie</code> 请求网站首页，返回首页内容。</p><p><img src="http://tc.xianyucoder.cn/blog20190920193847.png" alt="图1-4"></p><p>这整个过程需要的请求现在已经分析清楚了，接下来就是使用 Python 实现这个请求流程，不过是这样的话就配不上这个标题了。</p><p>先说说这个按照正常流程是怎么实现抓取绕过的：</p><ul><li>使用浏览器模拟技术请求目标网站，例如：Selenium、 PhantomJS等</li><li>破解请求 2 的加密参数使用请求库模拟整个请求过程</li></ul><p>这两个方法当然是可以抓取的，但是都不符合标题的<code>巧</code>字。</p><p>接下来给大家介绍一个专门为了绕过这个 CloudFlare 开发的 Python 库 <code>cloudflare-scrape</code></p><p>用上它就可以无感爬取使用了 CloudFlare 的网站，使用这个库非常简单。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>使用</p><p><code>pip install cfscrape</code></p><p>安装<code>cloudflare-scrape</code>，同时确认本地是否安装<code>node.js</code>开发环境，如果没有，需要安装配置<code>nodejs</code>开发环境。</p><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>处理 get 请求的 CloudFlare</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cfscrape</span><br><span class="line"><span class="comment"># 实例化一个create_scraper对象</span></span><br><span class="line">scraper = cfscrape.create_scraper()</span><br><span class="line"><span class="comment"># 请求报错，可以加上时延</span></span><br><span class="line"><span class="comment"># scraper = cfscrape.create_scraper(delay = 10)</span></span><br><span class="line"><span class="comment"># 获取网页源代码</span></span><br><span class="line">web_data = scraper.get(<span class="string">"https://wallhere.com/"</span>).content</span><br><span class="line">print(web_data)</span><br></pre></td></tr></table></figure><p>处理 post 请求的 CloudFlare</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import cfscrape</span></span><br><span class="line"><span class="comment"># 实例化一个create_scraper对象</span></span><br><span class="line">scraper = cfscrape.create_scraper()</span><br><span class="line"><span class="comment"># 获取真实网页源代码</span></span><br><span class="line">web_data = scraper.post(<span class="string">"http://example.com"</span>).content</span><br><span class="line">print(web_data)</span><br></pre></td></tr></table></figure><p>使用<code>cloudflare-scrape</code>后整个请求过程如丝般顺滑。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天的水文到这里就结束了，很高兴又水了一篇文章。</p><p>之后抽个时间讲讲请求 2 中的加密参数如何生成，这样就可以再水一篇，敬请期待~</p><p>EOF</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;巧破-Cloudflare-5秒盾&quot;&gt;&lt;a href=&quot;#巧破-Cloudflare-5秒盾&quot; class=&quot;headerlink&quot; title=&quot;巧破 Cloudflare 5秒盾&quot;&gt;&lt;/a&gt;巧破 Cloudflare 5秒盾&lt;/h2&gt;&lt;p&gt;相信下面这个界面大家
      
    
    </summary>
    
      <category term="反反爬" scheme="http://www.xianyucoder.cn/categories/%E5%8F%8D%E5%8F%8D%E7%88%AC/"/>
    
    
      <category term="反反爬" scheme="http://www.xianyucoder.cn/tags/%E5%8F%8D%E5%8F%8D%E7%88%AC/"/>
    
      <category term="Cloudflare" scheme="http://www.xianyucoder.cn/tags/Cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向-叮当快药 sign 加密分析</title>
    <link href="http://www.xianyucoder.cn/2019/09/16/%E6%AF%8F%E6%97%A5JS-%E5%8F%AE%E5%BD%93%E5%BF%AB%E8%8D%AF-MD5/"/>
    <id>http://www.xianyucoder.cn/2019/09/16/每日JS-叮当快药-MD5/</id>
    <published>2019-09-16T10:39:35.000Z</published>
    <updated>2019-09-30T02:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>今日份的网站</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aHR0cDovL3d3dy5kZGt5LmNvbS9jb21tb2RpdHkuaHRtbD9kZGt</span><br><span class="line"><span class="number">5</span>Y2FjaGU9YTdiMTllODc5ZDJmMmYyNzlkMzU2ZjVhZmE2ZDVjZmY=</span><br></pre></td></tr></table></figure><p>这个网站的加密比较简单，是那种新手做过一遍就对 JS 逆向充满信心的小练手。</p><h4 id="分析请求"><a href="#分析请求" class="headerlink" title="分析请求"></a>分析请求</h4><p>先分析请求，看看需要的参数有没什么搞头【图1-1】</p><p><img src="http://tc.xianyucoder.cn/blog20190923213839.png" alt="图1-1"></p><p>比较明显的是 sign 其他的参数好像没有什么特别的地方。</p><p>先定位 sign 的位置【图1-2】</p><p><img src="http://tc.xianyucoder.cn/blog20190923215026.png" alt="图1-2"></p><p>直接搜索参数就看到结果了，点击搜索的结果文件在文件内再搜索一次，可以看到有 3 个结果。【图1-3】</p><p><img src="http://tc.xianyucoder.cn/blog20190923215244.png" alt="图1-3"></p><p>到这里就看到 sign 的加密了。</p><p>接下来继续分析逻辑，这里的 sign 值是 <code>y</code>，<code>y</code>的值是通过<code>MD5(f)</code>获取的，而<code>f</code>又是<code>t.get(&quot;method&quot;) + p + r</code>的结果，经过一通分析，可以的得到下面的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l = t.keys().sort(), p = <span class="string">""</span>;</span><br><span class="line">            l.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> g <span class="keyword">in</span> l) &#123;</span><br><span class="line">  <span class="keyword">var</span> m = l[g];</span><br><span class="line">  p += m + t.get(m)</span><br><span class="line">&#125;</span><br><span class="line">sign = md5(t.get(<span class="string">"method"</span>) + p + r)</span><br></pre></td></tr></table></figure><p>接下来只需要把我们不知道的值通过断点的方式调试出来，这个加密我们就完成解密了。</p><p>所以先给不知道的值打上断点，不清楚就打上断点不要怕麻烦，像【图1-4】这样。</p><p><img src="http://tc.xianyucoder.cn/blog20190923220259.png" alt="图1-4"></p><p>重新请求一下，就进入到我们打的断点里了，我们可以通过在 console 中打印变量的值来理解逻辑。【图1-5】</p><p><img src="http://tc.xianyucoder.cn/blog20190923220652.png" alt="图1-5"></p><p>明白需要的变量的值之后，我们就可以开始扣取 JS 或者用 Python 复写加密的逻辑了。</p><p>因为这次的加密比较简单，我们试试用 Python 复写一遍加密。（主要是 Python 的 md5 用起来蛮舒服的）</p><p>这里的逻辑比较简单没啥好分析的，我就直接上代码了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sign</span><span class="params">()</span>:</span></span><br><span class="line">    timeStamp = time.time()</span><br><span class="line">    localTime = time.localtime(timeStamp)</span><br><span class="line">    strTime = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, localTime)</span><br><span class="line"></span><br><span class="line">    l = [<span class="string">"method"</span>, <span class="string">"orderTypeId"</span>, <span class="string">"orgcode"</span>, <span class="string">"pageNo"</span>, <span class="string">"pageSize"</span>, <span class="string">"plat"</span>, <span class="string">"platform"</span>, <span class="string">"shopId"</span>, <span class="string">"t"</span>, <span class="string">"v"</span>,</span><br><span class="line">         <span class="string">"versionName"</span>]</span><br><span class="line">    t = &#123;</span><br><span class="line">        <span class="string">'method'</span>: <span class="string">'ddsy.product.query.orgcode.product.list.b2c'</span>,</span><br><span class="line">        <span class="string">'orderTypeId'</span>: <span class="string">'0'</span>,</span><br><span class="line">        <span class="string">'orgcode'</span>: <span class="string">'010502,010503,010504,010505,010506,010507'</span>,</span><br><span class="line">        <span class="string">'pageNo'</span>: <span class="string">'1'</span>,</span><br><span class="line">        <span class="string">'pageSize'</span>: <span class="string">'100'</span>,</span><br><span class="line">        <span class="string">'plat'</span>: <span class="string">'H5'</span>,</span><br><span class="line">        <span class="string">'platform'</span>: <span class="string">'H5'</span>,</span><br><span class="line">        <span class="string">'shopId'</span>: <span class="string">'-1'</span>,</span><br><span class="line">        <span class="comment"># 't': '2019-9-23 22:4:16',</span></span><br><span class="line">        <span class="string">'t'</span>: <span class="string">'&#123;&#125;'</span>.format(strTime),</span><br><span class="line">        <span class="string">'v'</span>: <span class="string">'1.0'</span>,</span><br><span class="line">        <span class="string">'versionName'</span>: <span class="string">'3.2.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">11</span>):</span><br><span class="line">        m = l[i]</span><br><span class="line">        p += m + t.get(m)</span><br><span class="line">    f = t[<span class="string">'method'</span>] + p + <span class="string">'6C57AB91A1308E26B797F4CD382AC79D'</span></span><br><span class="line">    print(f)</span><br><span class="line">    sign = md5value(f).upper()</span><br><span class="line">    print(sign)</span><br><span class="line">    <span class="keyword">return</span> sign</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5value</span><span class="params">(s)</span>:</span></span><br><span class="line">    a = md5(s.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>到这里其实就没有什么难度了，直接带入 sign 请求就完事了。【图1-6】</p><p><img src="http://tc.xianyucoder.cn/blog20190923232755.png" alt="图1-6"></p><p>EOF</p><p><img src="http://tc.xianyucoder.cn/blogWechatIMG1956.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今日份的网站&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
      
    
    </summary>
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/categories/js%E9%80%86%E5%90%91/"/>
    
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/tags/js%E9%80%86%E5%90%91/"/>
    
      <category term="sign" scheme="http://www.xianyucoder.cn/tags/sign/"/>
    
      <category term="叮当快药" scheme="http://www.xianyucoder.cn/tags/%E5%8F%AE%E5%BD%93%E5%BF%AB%E8%8D%AF/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向-58同城密码加密分析</title>
    <link href="http://www.xianyucoder.cn/2019/09/16/%E6%AF%8F%E6%97%A5JS-58%E5%90%8C%E5%9F%8E%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E4%B8%8E%E6%8C%87%E7%BA%B9%E5%88%86%E6%9E%90-RSA/"/>
    <id>http://www.xianyucoder.cn/2019/09/16/每日JS-58同城密码加密与指纹分析-RSA/</id>
    <published>2019-09-16T10:39:35.000Z</published>
    <updated>2019-09-30T02:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>目标网站：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aHR0cHM6Ly9wYXNzcG9ydC41OC5jb20vbG9naW4vP3BhdGg</span><br><span class="line"><span class="number">9</span>aHR0cHMlM0EvL2Z6LjU4LmNvbS8mUEdUSUQ9MGQxMDAwMDAtMDAx</span><br><span class="line">My0wMjk0LTFjZWItYjU3NTBiZDIwNmU5JkNsaWNrSUQ9Mg==</span><br></pre></td></tr></table></figure><h4 id="抓包分析与加密定位"><a href="#抓包分析与加密定位" class="headerlink" title="抓包分析与加密定位"></a>抓包分析与加密定位</h4><p>老规矩先抓包看看【图1-1】</p><p><img src="http://tc.xianyucoder.cn/blog20190925190359.png" alt="图1-1"></p><p>今天主要分析的是划线的三个参数，先一个一个来研究一下。</p><p>先看看密码的加密，按照之前的思路我们测试了<code>password</code>的相关搜索项，但是搜索出来的结果都不尽如人意。【图1-2】</p><p>同时这个请求也不是<code>XHR</code>请求，所以<code>xhr</code>断点也用不上了。</p><p><img src="http://tc.xianyucoder.cn/blog20190925190753.png" alt="图1-2"></p><p>搜索的结果中比较有相关性的是【图1-2】标注的部分，但是在文件的搜索项里搜索<code>password</code>是找不到加密位置的。</p><p>我简单总结了几种办法，虽然并不一定适用于其他网站的加密，算是提供一种新的思路。</p><p>第一、搜索相关的的提示语，就像在之前的我做的第一个 APP 逆向的项目中，我就是搜索相关的提示语找到了扣费逻辑的代码，这里也可以按照这样的思路。</p><p>在这个网站的加密里点击登陆，点击后按钮变为<code>登录中...</code>，搜索相关提示语再逐步打断点一直追下去是可以找到加密位置的，不过这是个下下策，耗时太长，很容易追丢了，为了这个不值当。（不推荐使用）</p><p>第二、参考开头的搜索关键字的方法，这里搜索的是<code>encrypt</code>，经常遇到加密的变量或方法是<code>encrypt(XX)</code>这样的形式。</p><p>第三、试试从网页中找找答案，之前做过一些简单的例子是将 js 的代码直接写到页面中自执行或者采用隐藏域传递值的方式，比如：像<code>PublicKey</code>这类比较有特色的值，如果能找到对我们的帮助是很大的。</p><p>按照上面总结的几种方法，我们再次搜索【图1-3】</p><p><img src="http://tc.xianyucoder.cn/blog20190925193129.png" alt="图1-3"></p><p>又搜索到这个熟悉的文件，这次我们进去搜索一次，这次找到了好多类似加密的地方，为了省事我把所有相关的值都打上了断点，再次登录。【图1-4】</p><p><img src="http://tc.xianyucoder.cn/blog20190925193706.png" alt="图1-4"></p><p>到这里就定位到加密的地方了。</p><p>继续追进去可以看到进入的是一个<code>VM</code>【图1-5】</p><p><img src="http://tc.xianyucoder.cn/blog20190925193948.png" alt="图1-5"></p><p>到这里就没有什么难度了，密码的加密就是 <code>RSA</code> + <code>eval</code>。</p><p>如果你很幸运先找到了<code>eval</code>加密的地方，但是不知道怎么解决，可以参考之前一篇关于<code>js</code>混淆的文章。</p><p>—-&gt; 点我看文章</p><p>或者直接打开浏览器的<code>开发者工具</code>切换到<code>console</code>选项卡，把相关的<code>eval</code>代码粘贴进去，将代码开头的<code>eval</code>替换为<code>console.log</code>，就可以得到原来的代码了。【图1-6】</p><p><img src="http://tc.xianyucoder.cn/blog20190925194535.png" alt="图1-6"></p><p>接下来看的是两个指纹相关的参数，这里就比较简单了，直接搜索<code>fingerprint</code>就可以找到相关加密文件，直接在里面打断点就可以了。【图1-7】</p><p><img src="http://tc.xianyucoder.cn/blog20190925194830.png" alt></p><p>这里的注意点是想要重新生成指纹，记得要刷新页面才可以。</p><h4 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h4><p>关于指纹的加密生成讲的比较简单，需要学习案例的朋友可以访问下面的网址。</p><p><a href="https://lengyue.me/" target="_blank" rel="noopener">https://lengyue.me/</a></p><p>也可以看看冷月打来之前的关于某个网站指纹加密的视频教程。</p><p>链接 : <a href="https://pan.baidu.com/s/1Y8pcacZbHF1DXW0znzmZKQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1Y8pcacZbHF1DXW0znzmZKQ</a>  密码:vkmf</p><p>失效请留言。</p><p>EOF</p><p><img src="http://tc.xianyucoder.cn/blogWechatIMG1956.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目标网站：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/categories/js%E9%80%86%E5%90%91/"/>
    
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/tags/js%E9%80%86%E5%90%91/"/>
    
      <category term="密码加密" scheme="http://www.xianyucoder.cn/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    
      <category term="58同城" scheme="http://www.xianyucoder.cn/tags/58%E5%90%8C%E5%9F%8E/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向-新浪二手房与房天下加密分析</title>
    <link href="http://www.xianyucoder.cn/2019/09/07/%E6%AF%8F%E6%97%A5JS-%E6%88%BF%E5%A4%A9%E4%B8%8B+%E6%96%B0%E6%B5%AA%E4%BA%8C%E6%89%8B%E6%88%BF-RSA/"/>
    <id>http://www.xianyucoder.cn/2019/09/07/每日JS-房天下+新浪二手房-RSA/</id>
    <published>2019-09-07T10:39:35.000Z</published>
    <updated>2019-09-30T02:42:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="X天下密码加密分析"><a href="#X天下密码加密分析" class="headerlink" title="X天下密码加密分析"></a>X天下密码加密分析</h4><p>本次的受害者：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aHR0cHM6Ly9wYXNzcG9ydC5mYW5nLmNvbS8=</span><br></pre></td></tr></table></figure></p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>通过输入错误密码抓包查看加密字段。【图1-1】</p><p><img src="http://tc.xianyucoder.cn/blog20190901141951.png" alt="图1-1"></p><p>直接通过检索<code>pwd:</code>定位加密位置【图1-2】。</p><p><img src="http://tc.xianyucoder.cn/blog20190901142223.png" alt="图1-2"></p><p>根据检索结果给对应的位置打上断点【图1-3】，并把划线的代码复制出来备用。</p><p><img src="http://tc.xianyucoder.cn/blog20190901142323.png" alt="图1-3"></p><p>重新发起请求，发现这些参数大概是下面这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// that.password.val() 输入的密码：11111111111</span></span><br><span class="line"><span class="comment">// encryptedString 是加密方法</span></span><br><span class="line">encryptedString(key_to_encode, that.password.val())</span><br></pre></td></tr></table></figure><p>根据上面分析就少了一个 <code>key_to_encode</code>，直接检索可以找到下面的结果【图1-4】：</p><p><img src="http://tc.xianyucoder.cn/blog20190901143025.png" alt="图1-4"></p><p>很明显的 RSA 加密，同时追进去就看到<code>encryptedString</code>的加密逻辑了，一起扣出来组装一下就得到加密逻辑了【图1-5】：</p><p><img src="http://tc.xianyucoder.cn/blog20190901143250.png" alt="图1-5"></p><h4 id="XX二手房密码加密分析"><a href="#XX二手房密码加密分析" class="headerlink" title="XX二手房密码加密分析"></a>XX二手房密码加密分析</h4><p>本次的受害者：</p><p>aHR0cDovL2ouZXNmLmxlanUuY29tL3VjZW50ZXIvbG9naW4=</p><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>同样使用错误密码测试登陆【图2-1】</p><p><img src="http://tc.xianyucoder.cn/blog20190901152811.png" alt="图2-1"></p><p>这里<code>password</code>和<code>ckey</code>两个参数疑似加密，我们先检索一遍。</p><p><code>ckey</code>是在页面适用隐藏域传递的值【图2-2】</p><p><img src="http://tc.xianyucoder.cn/blog20190901152959.png" alt="图2-2"></p><p><code>password</code>的检索结果比较多，不过从文件名看第三个文件关联性比较强。【图2-3】</p><p><img src="http://tc.xianyucoder.cn/blog20190901153038.png" alt="图2-4"></p><p>我们打开第三个文件，并格式化搜索一下【图2-4】。</p><p><img src="http://tc.xianyucoder.cn/blog20190901153443.png" alt="图2-4"></p><p>有没有发现这个加密规律和上面 X天下 的加密非常像，而且还有RSA的加密标志，<code>publickey</code> 连下面的  <code>encryptedString</code> 加密方法都似曾相识【图2-5】？同时参考 X天下例子的【图1-3】</p><p><img src="http://tc.xianyucoder.cn/blog20190901153405.png" alt=" "></p><p>到这里就没有悬念了，直接用上一个例子的代码就可以实现加密，如果你想自己扣出来也是可以的，但是咸鱼感觉没有必要。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;X天下密码加密分析&quot;&gt;&lt;a href=&quot;#X天下密码加密分析&quot; class=&quot;headerlink&quot; title=&quot;X天下密码加密分析&quot;&gt;&lt;/a&gt;X天下密码加密分析&lt;/h4&gt;&lt;p&gt;本次的受害者：&lt;br&gt;&lt;figure class=&quot;highlight python
      
    
    </summary>
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/categories/js%E9%80%86%E5%90%91/"/>
    
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/tags/js%E9%80%86%E5%90%91/"/>
    
      <category term="密码加密" scheme="http://www.xianyucoder.cn/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    
      <category term="新浪二手房" scheme="http://www.xianyucoder.cn/tags/%E6%96%B0%E6%B5%AA%E4%BA%8C%E6%89%8B%E6%88%BF/"/>
    
      <category term="房天下" scheme="http://www.xianyucoder.cn/tags/%E6%88%BF%E5%A4%A9%E4%B8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向-粉笔网密码加密</title>
    <link href="http://www.xianyucoder.cn/2019/09/06/%E6%AF%8F%E6%97%A5JS-%E7%B2%89%E7%AC%94%E7%BD%91-RSA/"/>
    <id>http://www.xianyucoder.cn/2019/09/06/每日JS-粉笔网-RSA/</id>
    <published>2019-09-06T10:39:35.000Z</published>
    <updated>2019-09-30T02:42:28.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aHR0cHM6Ly9mZW5iaS5jb20vcGFnZS9ob21l</span><br></pre></td></tr></table></figure><h4 id="参数加密的逻辑分析"><a href="#参数加密的逻辑分析" class="headerlink" title="参数加密的逻辑分析"></a>参数加密的逻辑分析</h4><p>先抓包看看这次分析的参数【图1-1】</p><p><img src="http://tc.xianyucoder.cn/blog20190911203157.png" alt></p><p>这个参数的值看着像<code>Base64</code> ，我们不急着下结论，先搜索参数名看看。</p><p>有读者朋友纠结于搜索<code>password = or password：</code>这样需要搜索两遍是不是浪费时间了，不如直接搜索<code>password</code>来的方便快捷。</p><p>咸鱼之所以这样搜索是出于自己的习惯，定位加密位置的方法有很多大家有兴趣可以多尝试不要局限于搜索参数，例如：Js Hook，XHR 断点等等，怎么舒服怎么来就好。</p><p>经过搜索参数名<code>password:</code>在一个文件中定位到 3 处疑似加密的位置。【图1-2】</p><p><img src="http://tc.xianyucoder.cn/blog20190911205323.png" alt="图1-2"></p><p>这里有两种方法判断加密位置：</p><ul><li><p>给所有搜索到的结果打上断点，再次刷新看看进入到哪个断点当中</p></li><li><p>阅读上下文，分析大概的代码逻辑</p></li></ul><p>我们用第一种试试，打上断点重新发起请求，可以看到成功断上了。【图1-3】</p><p>这里的<code>this.password</code>是测试的密码，我们需要分析的就是这个<code>this.encrypt</code>的逻辑是什么样的。</p><p><img src="http://tc.xianyucoder.cn/blog20190911210506.png" alt="图1-3"></p><p>我们进入到<code>this.encrypt</code>这个函数中，发现有熟悉的 RSA 加密标志<code>this.publicKey</code>【图1-4】</p><p><img src="http://tc.xianyucoder.cn/blog20190911214408.png" alt="图1-4"></p><p>在文件中再搜索一次<code>publicKey</code>，能够看到文件中已经声明了这个变量【图1-5】</p><p><img src="http://tc.xianyucoder.cn/blog20190911211206.png" alt="图1-5"></p><p>继续进入到函数内部查看逻辑，发现进入的就是加密逻辑的文件了。【图1-6】</p><p><img src="http://tc.xianyucoder.cn/blog20190911213812.png" alt="图1-6"></p><p>这一整个流程分析下来，可以发现前面的传参部分，在<code>Python</code>调用中我们完全可以跳过，只要给【图1-6】中的Js加密逻辑传入<code>publicKey</code>与<code>明文密码</code>就可以实现这个网站的密码加密逻辑了，既然这么简单，我们就动手试试。</p><h4 id="参数加密的代码实现"><a href="#参数加密的代码实现" class="headerlink" title="参数加密的代码实现"></a>参数加密的代码实现</h4><p>接上面的分析，我们直接复制了【图1-6】截图所示的全部代码。</p><p>接着在编辑器中加上一些我们自己的逻辑类似这样【图2-1】。</p><p><img src="http://tc.xianyucoder.cn/blog20190911212452.png" alt="图2-1"></p><p>注：前939行都是复制的 Js 文件代码</p><p>试着运行一下，看看报错。</p><p>运行的报错提示，<code>window is undefine</code>【图2-2】，遇到这种情况我们可以试试在代码上加上<code>window</code>的声明。</p><p><img src="http://tc.xianyucoder.cn/blog20190911212622.png" alt="图2-2"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">window</span> = &#123;&#125;</span><br></pre></td></tr></table></figure><p>再次运行看看，这里再次提示<code>{} is not a function</code>，【图2-3】到这里新手朋友有点慌了，不知道怎么处理。</p><p><img src="http://tc.xianyucoder.cn/blog20190911213102.png" alt="图2-3"></p><p> 比较方便的处理方式是直接在<code>(function(av) {</code>前加上<code>!</code>，就是这么简单。</p><p>具体用法，这里套用一下百度：</p><blockquote><p>使用括号包裹定义函数体，解析器将会以函数表达式的方式去调用定义函数。也就是说，任何能将函数变成一个函数表达式的作法，都可以使解析器正确的调用定义函数。而 ! 就是其中一个，而 + - || 都有这样的功能。</p></blockquote><p>继续调试，这次提示变成了<code>navigator is not defined</code>【图2-4】</p><p><img src="http://tc.xianyucoder.cn/blog20190911213651.png" alt="图2-4"></p><p>有了上次的经验，我们在代码里加入声明<code>navigator</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> navigator = &#123;&#125;</span><br></pre></td></tr></table></figure><p>再次运行就得到加密后的结果咯~【图2-5】</p><p><img src="http://tc.xianyucoder.cn/blog20190911214134.png" alt="图2-5"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这次的加密是比较简单的 RSA 加密，使用文件中包含的公钥对密码的值进行加密，且Js代码没有进过混淆，适合新手练手增加手感。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/categories/js%E9%80%86%E5%90%91/"/>
    
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/tags/js%E9%80%86%E5%90%91/"/>
    
      <category term="RSA" scheme="http://www.xianyucoder.cn/tags/RSA/"/>
    
      <category term="密码加密" scheme="http://www.xianyucoder.cn/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    
      <category term="粉笔网" scheme="http://www.xianyucoder.cn/tags/%E7%B2%89%E7%AC%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向-极贷助手密码加密</title>
    <link href="http://www.xianyucoder.cn/2019/09/05/%E6%AF%8F%E6%97%A5JS-%E6%9E%81%E8%B4%B7%E5%8A%A9%E6%89%8B-aes/"/>
    <id>http://www.xianyucoder.cn/2019/09/05/每日JS-极贷助手-aes/</id>
    <published>2019-09-05T10:39:35.000Z</published>
    <updated>2019-09-30T02:42:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="极X助手"><a href="#极X助手" class="headerlink" title="极X助手"></a>极X助手</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aHR0cHM6Ly93d3cuamlkYWlob21lLmNvbS9vZmZpY2VyLyMvbG9naW4=</span><br></pre></td></tr></table></figure><p>先抓包看看这次要分析的参数。【图1-1】</p><p><img src="http://tc.xianyucoder.cn/blog20190904212818.png" alt="图1-1"></p><p>看到【图1-1】里是没有加密参数名的。所以为了快速定位到加密的位置，我们试试 XHR 断点。</p><p>切换到 控制台 -  Source 选项卡 ，如【图1-2】位置填入下面的内容。</p><p><img src="http://tc.xianyucoder.cn/blog20190904214659.png" alt="图1-2"></p><p>接着我们再发起一次请求，可以看到断点打上了。【图1-3】</p><p><img src="http://tc.xianyucoder.cn/blog20190904215011.png" alt="图1-3"></p><p>我们点击左下角的<code>{}</code>格式化 JS 看看断点断上的位置有没有我们需要的内容。【图1-4】</p><p><img src="http://tc.xianyucoder.cn/blog20190904215207.png" alt="图1-4"></p><p>我们可以看到这里函数 <code>y</code>传入一个参数<code>t</code>，<code>t</code>中包含我们需要的提交数据【图1-5】。但是在这个断点位置并不能找到参数加密的地方，所以我们需要点击右侧的堆栈往上看看。</p><p><img src="http://tc.xianyucoder.cn/blog20190904215613.png" alt="图1-5"></p><p>我们通过查看堆栈信息，找到了这里【图1-6】。发现在这里出现了 <code>params</code>相关的的操作，所以这里的可能包含的就是我们需要的加密位置，我们根据提示进去看看这里的加密逻辑是什么样的。</p><p><img src="http://tc.xianyucoder.cn/blog20190904220154.png" alt="图1-6"></p><p>可以看到这里把经过处理的密码和用户名传入后，再次做了另一次加密处理后得到了变量<code>i</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = t.randomKey(<span class="number">16</span>), i = t.aesEncrypt(<span class="built_in">JSON</span>.stringify(e), r);</span><br></pre></td></tr></table></figure><p><img src="http://tc.xianyucoder.cn/blog20190904220330.png" alt="图1-7"></p><p>我们分别把变量<code>i</code>需要的参数分别跟进去看看生成规则。【图1-8】是变量<code>r</code>的生成规则是一串随机的字符串。</p><p><img src="http://tc.xianyucoder.cn/blog20190904220756.png" alt="图1-8"></p><p>接下来是加密变量<code>i</code>的加密方法【图1-9】。</p><p><img src="http://tc.xianyucoder.cn/blog20190904220853.png" alt="图1-9"></p><p>接下来只需要把这些参数的方法复制到编辑器中进一步的补全就可以了。</p><p>Tip: 这里的参数<code>e</code>是我们传入的用户名和密码，在【图1-6】的 54-55 行中传入，且密码经过了一层MD5的加密。</p><p>这里很多朋友纠结于类似 <code>i.enc.Utf8.parse</code> 这里的<code>i</code>如何补全，其实这里的<code>i</code> 就是我们常用的<code>CryptoJS</code>，只要引入后，直接替换就可以了，不用扣取整个JS。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;极X助手&quot;&gt;&lt;a href=&quot;#极X助手&quot; class=&quot;headerlink&quot; title=&quot;极X助手&quot;&gt;&lt;/a&gt;极X助手&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/categories/js%E9%80%86%E5%90%91/"/>
    
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/tags/js%E9%80%86%E5%90%91/"/>
    
      <category term="密码加密" scheme="http://www.xianyucoder.cn/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    
      <category term="极贷助手" scheme="http://www.xianyucoder.cn/tags/%E6%9E%81%E8%B4%B7%E5%8A%A9%E6%89%8B/"/>
    
      <category term="AES" scheme="http://www.xianyucoder.cn/tags/AES/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向-空中网密码加密</title>
    <link href="http://www.xianyucoder.cn/2019/09/04/%E6%AF%8F%E6%97%A5JS-%E7%A9%BA%E4%B8%AD%E7%BD%91/"/>
    <id>http://www.xianyucoder.cn/2019/09/04/每日JS-空中网/</id>
    <published>2019-09-04T10:39:35.000Z</published>
    <updated>2019-09-30T02:43:02.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aHR0cHM6Ly9wYXNzcG9ydC5rb25nemhvbmcuY29tL2xvZ2lu</span><br></pre></td></tr></table></figure><h4 id="参数位置分析"><a href="#参数位置分析" class="headerlink" title="参数位置分析"></a>参数位置分析</h4><p>先来看看加密的请求【图1-1】，之前在一篇加密总结的文章中提到过关于这个网站的加密，感兴趣的朋友可以回顾一下。</p><p><img src="http://tc.xianyucoder.cn/blog20190914151352.png" alt="图1-1"></p><p>之前介绍过很多关于加密参数如何搜索的文章，就不啰嗦咯。</p><blockquote><p>除了搜索加密参数之外，同样还要注意<code>id</code> 和 <code>calssname</code>等标志性的属性，能够帮助我们进一步定位加密位置。</p></blockquote><p>通过密码框的<code>id = password_txt</code> 快速定位至网站的加密入口。【图1-2】</p><p><img src="http://tc.xianyucoder.cn/blog20190914153646.png" alt="图1-2"></p><p>通过逐步调试进入虚拟引擎中加密码的位置打上断点。【图1-3】</p><p><img src="http://tc.xianyucoder.cn/blog20190914154057.png" alt="图1-4"></p><p>上图中的<code>encrypt</code>这个方法才是我们需要的加密方法，所以继续最近去看看逻辑。</p><p>这里通过悬停在对应方法上没有提示加密的位置的，小伙伴表示无法进入下一步，我们可以选中方法后点击提示即可跳转【图1-4】</p><p><img src="http://tc.xianyucoder.cn/blog20190914154308.png" alt="图1-4"></p><p>顺利跳转进加密方法的位置后，就可以直接抠出来补全了。【图1-5】</p><p><img src="http://tc.xianyucoder.cn/blog20190914154752.png" alt="图1-5"></p><p>tip: 这里的第二个参数是在【图1-1】中上一条请求中返回的哦</p><h4 id="补全加密JS"><a href="#补全加密JS" class="headerlink" title="补全加密JS"></a>补全加密JS</h4><p>先扣取【图1-5】中框选的方法到编辑器中，根据断点把需要的参数传入【图2-1】</p><p><img src="http://tc.xianyucoder.cn/blog20190914165416.png" alt="图2-1"></p><p>这样在编辑器中的结果就像现在这样了【图2-2】</p><p><img src="http://tc.xianyucoder.cn/blog20190914165549.png" alt="图2-2"></p><p>运行之后就是得到的加密参数喽。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个网站的加密比较适合有一点点的新手作为练手项目，涉及多次的浏览器调试可以很好的帮助新手进一步的了解浏览器的调试技巧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/categories/js%E9%80%86%E5%90%91/"/>
    
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/tags/js%E9%80%86%E5%90%91/"/>
    
      <category term="密码加密" scheme="http://www.xianyucoder.cn/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    
      <category term="空中网" scheme="http://www.xianyucoder.cn/tags/%E7%A9%BA%E4%B8%AD%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向-咪咕视频密码加密与指纹分析</title>
    <link href="http://www.xianyucoder.cn/2019/09/03/%E6%AF%8F%E6%97%A5JS-%E5%92%AA%E5%92%95%E8%A7%86%E9%A2%91-RSA/"/>
    <id>http://www.xianyucoder.cn/2019/09/03/每日JS-咪咕视频-RSA/</id>
    <published>2019-09-03T10:39:35.000Z</published>
    <updated>2019-09-30T02:43:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>先来看看今天的受害者：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aHR0cDovL3d3dy5taWd1dmlkZW8uY29tL21ncy93ZWJzaXRlL3ByZC9pbmRleC5odG1s</span><br></pre></td></tr></table></figure><h4 id="一、分析密码加密"><a href="#一、分析密码加密" class="headerlink" title="一、分析密码加密"></a>一、分析密码加密</h4><p>这次分析的是他登陆的三个参数，先分析登陆逻辑，抓个包看看。</p><p>可以看到这里用的是弹出的窗口登陆【图1-1】，为了避免主页其他元素的干扰抓包，我们可以通过右键 查看框架源代码 的方式打开登陆框分析抓包【图1-2】。</p><p><img src="http://tc.xianyucoder.cn/blog20190831193910.png" alt="图1-1"></p><p><img src="http://tc.xianyucoder.cn/blog20190831194312.png" alt="图1-2"></p><p>把打开的源代码页面地址栏中的 <code>view-source:</code>删除即可打开以下页面【图1-3】：</p><p><img src="http://tc.xianyucoder.cn/blog20190831195150.png" alt="图1-3"></p><p>接下来用错误的账号密码登陆一波，可以看到如下的包【图1-4】，不过通过上面的 publickey 隐隐猜到这里的加密参数可能和 RSA 有关，先来找找密码加密的位置：</p><p><img src="http://tc.xianyucoder.cn/blog20190831201401.png" alt="图1-4"></p><p>照常搜索一下 <code>enpassword</code> ，预料之中是没有搜索到有用的结果【图1-5】，不过定位元素可以通过 name 定位 也可以通过 class 定位，所以同样试试 <code>J_RsaPsd</code>，果然找到像样的文件了【图1-6】。</p><p><img src="http://tc.xianyucoder.cn/blog20190831202616.png" alt="图1-5"></p><p><img src="http://tc.xianyucoder.cn/blog20190831202207.png" alt="图1-6"></p><p>在打开的文件里检索<code>J_RsaPsd</code>，可以看到有3个相关的结果(熟悉加密的已经可以看出这里是 RSA 加密)，我们通过把所有相关的结果都打上断点【图1-6】，并通过重新发起一次登录请求，来判断哪个<code>J_RsaPsd</code>是密码的加密逻辑。</p><p><img src="http://tc.xianyucoder.cn/blog20190831203150.png" alt="图1-7"></p><p>通过重新发起请求，断点断在 333 行【图1-8】。</p><p><img src="http://tc.xianyucoder.cn/blog20190831204014.png" alt="图1-8"></p><p>我们先复制整段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.setPublic(a.result.modulus, a.result.publicExponent);</span><br><span class="line"><span class="keyword">var</span> d = c.encrypt(b.val());</span><br><span class="line">b.siblings(<span class="string">".J_RsaPsd"</span>).val(d)</span><br></pre></td></tr></table></figure><p>我们通过控制台看看这些参数分别是什么【图1-9】。</p><p><img src="http://tc.xianyucoder.cn/blog20190831204159.png" alt="图1-9"></p><p>通过前文抓包和JS页面的代码，我们判断密码的加密是RSA加密，所以我们就需要找齐RSA加密的需要的几个要素，比如他的公钥 ，因为RSA是非对称加密本地使用公钥加密，服务器上使用私钥解密。再看看【图1-8】上的几个参数不知道你们有没想起开头【图1-4】我提及的那条抓包。我们切换到 控制台-Network 看看【图1-10】。</p><p><img src="http://tc.xianyucoder.cn/blog20190831210520.png" alt="图1-10"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"status"</span>:<span class="number">2000</span>,<span class="attr">"message"</span>:<span class="string">""</span>,<span class="attr">"header"</span>:&#123;&#125;,<span class="attr">"result"</span>:&#123;<span class="attr">"publicExponent"</span>:<span class="string">"010001"</span>,<span class="attr">"modulus"</span>:<span class="string">"00833c4af965ff7a8409f8b5d5a83d87f2f19d7c1eb40dc59a98d2346cbb145046b2c6facc25b5cc363443f0f7ebd9524b7c1e1917bf7d849212339f6c1d3711b115ecb20f0c89fc2182a985ea28cbb4adf6a321ff7e715ba9b8d7261d1c140485df3b705247a70c28c9068caabbedbf9510dada6d13d99e57642b853a73406817"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>是不是和我们在【图1-9】中打印出来的数值完全相同</p><p>tip : 这里的<code>b.val()</code>是我输入的错误密码。</p><p>这里我们找齐了加密需要的参数，其实我觉得没必要扣JS，但是我知道。。</p><p>不要我觉得，你要你觉得</p><p>所以偷懒用之前扣的代码测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-----------此处省略<span class="number">500</span>行-----------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bodyRSA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//setMaxDigits(130);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> key = RSAUtils.getKeyPair(<span class="string">"010001"</span>,<span class="string">""</span>,<span class="string">"00833c4af965ff7a8409f8b5d5a83d87f2f19d7c1eb40dc59a98d2346cbb145046b2c6facc25b5cc363443f0f7ebd9524b7c1e1917bf7d849212339f6c1d3711b115ecb20f0c89fc2182a985ea28cbb4adf6a321ff7e715ba9b8d7261d1c140485df3b705247a70c28c9068caabbedbf9510dada6d13d99e57642b853a73406817"</span>);</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_encrypt</span>(<span class="params">password</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    key = bodyRSA();</span><br><span class="line">    <span class="keyword">var</span> a = RSAUtils.encryptedString(key,password)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//var b = RSAUtils.encryptedString(key,username)</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'----------------------------------'</span>)</span><br><span class="line">    <span class="comment">//console.log(b)</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">get_encrypt(<span class="string">'11111111111'</span>)</span><br></pre></td></tr></table></figure><h4 id="二、分析FingerPrintDetail与fingerPrint"><a href="#二、分析FingerPrintDetail与fingerPrint" class="headerlink" title="二、分析FingerPrintDetail与fingerPrint"></a>二、分析FingerPrintDetail与fingerPrint</h4><p>根据第一部分的【图1-5】和图【1-6】可以很快定位加密的位置，这里就不说了【图2-1】。</p><p><img src="http://tc.xianyucoder.cn/blog20190831231000.png" alt="图2-1"></p><p>追进去分析一下<code>rsaFingerprint</code>的逻辑，可以看到其实和密码加密用的是一样的RSA加密【图2-2】只是部分参数不同。</p><p><img src="http://tc.xianyucoder.cn/blog20190831231157.png" alt="图2-2"></p><p>这里比较疑惑的是<code>$.fingerprint.result</code>和<code>$.fingerprint.details</code>是怎么来的。</p><p>通过检索<code>$.fingerprint</code>根据查找的结果找到他的位置【图2-3】</p><p><img src="http://tc.xianyucoder.cn/blog20190831231614.png" alt="图2-3"></p><p>继续向上查找，最终找到这里，发现是根据浏览器的请求头等信息生成的一串哈希值【图2-4】。</p><p><img src="http://tc.xianyucoder.cn/blog20190831232044.png" alt="图2-4"></p><p>这个值如果不修改请求头信息，那么这个值就是固定不变的，如果修改请求头信息，那么就需要重新生成这段hash，这就是这个的浏览器指纹信息。</p><p>因为我们这里只是抱着学习的态度学习，所以就不瞎搞，不过这个整段的代码也比较简单没事可以扣一扣。</p><p>tip: 如果想要分析这个指纹的算法，记得要刷新一下页面才可以进入断点。</p><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>结合之前的建议，文章的配图都标注了序号，希望能够起到一定梳理思路的作用。</p><p>这个网站的加密总体还是只用RSA的加密算法就可以搞定了，整体加密算法比较简单有经验的老哥直接通过加密库就可以实现，如果想练练手的也可以抠出来试试，只要头发多，肝就完事了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h4&gt;&lt;p&gt;先来看看今天的受害者：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/categories/js%E9%80%86%E5%90%91/"/>
    
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/tags/js%E9%80%86%E5%90%91/"/>
    
      <category term="密码加密" scheme="http://www.xianyucoder.cn/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    
      <category term="咪咕视频" scheme="http://www.xianyucoder.cn/tags/%E5%92%AA%E5%92%95%E8%A7%86%E9%A2%91/"/>
    
      <category term="指纹加密" scheme="http://www.xianyucoder.cn/tags/%E6%8C%87%E7%BA%B9%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向-楚楚街密码加密</title>
    <link href="http://www.xianyucoder.cn/2019/09/02/%E6%AF%8F%E6%97%A5JS-xx%E8%A1%97%E7%99%BB%E9%99%86%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86-md5+rsa/"/>
    <id>http://www.xianyucoder.cn/2019/09/02/每日JS-xx街登陆密码加密-md5+rsa/</id>
    <published>2019-09-02T10:39:35.000Z</published>
    <updated>2019-09-30T02:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="XX-街登陆密码加密"><a href="#XX-街登陆密码加密" class="headerlink" title="XX 街登陆密码加密"></a>XX 街登陆密码加密</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aHR0cDovL3NlbGxlci5jaHVjaHVqaWUuY29tL3NxZS5waHA/cz0vVXNlci9pbmRleA==</span><br></pre></td></tr></table></figure><p>这个加密太简单了，五秒定位真的不是吹，所以直接来。</p><p>输入错误的账号密码，发起登陆请求，可以看到登录包里有个<code>password</code>的加密字段。所以我们依次搜索<code>password:</code>+<code>password :</code>+<code>password=</code>+<code>password =</code></p><p>很快得到下面的结果【图1-1】，直接用python实现就完事了~</p><p><img src="http://tc.xianyucoder.cn/blog20190903214813.png" alt="图1-1"></p><h4 id="X博登陆密码与相关加密参数解析"><a href="#X博登陆密码与相关加密参数解析" class="headerlink" title="X博登陆密码与相关加密参数解析"></a>X博登陆密码与相关加密参数解析</h4><p>aHR0cHM6Ly93d3cud2VpYm8uY29tL2xvZ2luLnBocA==</p><p>用 Chrome 浏览器抓包相信大家都会，前面抓包我们跳过，直接到加密参数分析的地方。</p><p>Tip: 这次的加密不是异步的  不要在 XHR 选项卡傻乎乎的等了。</p><p>微博登陆框是嵌在页面中的加上微博的登陆页面图片以及要加载的东西很多，所以我们需要注意的包主要有两个：</p><ul><li>登陆前返回相关加密秘钥的包【图2-1】</li><li>发起登陆请求的包【图2-2】</li></ul><p><img src="http://tc.xianyucoder.cn/blog20190903220641.png" alt="图2-1"></p><p><img src="http://tc.xianyucoder.cn/blog20190903220923.png" alt="图2-2"></p><p>到这里就很清晰了，我们搞定 su 和 sp 就完事了。</p><p>先来看看 su 这个其实不要搜索，看着是不是很像我们开头的编码结果，由 a-zA-Z[0-9]+/= 这几种字符组成的编码 熟悉的就只有 Base64 , 我们直接找一个在线工具验证一下我们的猜想。【图2-3】</p><p><img src="http://tc.xianyucoder.cn/blog20190903221245.png" alt="图2-3"></p><p>当然我们也可以试试搜索 参数名 su 【图2-4】，很明显搜索结果也验证了我们的猜想。</p><p><img src="http://tc.xianyucoder.cn/blog20190903221529.png" alt="图2-4"></p><p>接下来看看 sp</p><p>在我们上面搜索 su 的地方我们找到了密码加密的地方，已经用红框框出主要的逻辑【图2-5】，接下来我们打上断点找找缺失的参数都是什么。</p><p><img src="http://tc.xianyucoder.cn/blog20190903222315.png" alt="图2-5"></p><p>这里的参数都是比较简单的首先是 me.servertime 、me.rsaPubkey 和  me.nonce【图2-6】 这三个参数在上一个请求包都有同名的参数返回可以参考【图2-1】。</p><p><img src="http://tc.xianyucoder.cn/blog20190903222841.png" alt="图2-6"></p><p>我们现在已经找齐了全部的参数，接下来需要切换到 webstorm 中调试出我们整体的加密算法。</p><p>直接粘贴 789 - 791 行的代码到编辑框中补全成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_sp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="keyword">new</span> sinaSSOEncoder.RSAKey;</span><br><span class="line">    f.setPublic(me.rsaPubkey, <span class="string">"10001"</span>);</span><br><span class="line">    b = f.encrypt([me.servertime, me.nonce].join(<span class="string">"\t"</span>) + <span class="string">"\n"</span> + b)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line">get_sp()</span><br></pre></td></tr></table></figure><p>虽然知道运行肯定报错，但是我们需要的就是报错的信息。【图2-7】</p><p><img src="http://tc.xianyucoder.cn/blog20190903223631.png" alt="2-7"></p><p>提示  <code>sinaSSOEncoder is not defined</code> ，我们回到浏览器调试窗口找 <code>sinaSSOEncoder</code>在哪儿定义的。可以直接在页面中搜索 <code>var sinaSSOEncoder</code></p><p>结果就只有一个【图2-8】</p><p><img src="http://tc.xianyucoder.cn/blog20190903223944.png" alt="图2-8"></p><p>接下来复制 <code>sinaSSOEncoder</code>的全部内容到编辑器中，第1048-1981行。继续运行并提示<code>navigator is not defined</code>，我们定义它为<code>{}</code>。接下来会提示 <code>me</code> 未定义【图2-9】。</p><p><img src="http://tc.xianyucoder.cn/blog20190903224444.png" alt="图2-9"></p><p>但是我们调试过都知道这个 me.rsaPubkey 是在【图2-1】中返回的，所以我们把它替换掉。同理替换到我们已知的的其他参数。现在就只剩下 <code>b</code> 参数是未知的了。</p><p>我们向下运行，可以看到<code>b</code>参数就是我们输入的密码【图2-10】，我们继续替换再次运行，发现没有东西输出，也没有报错，我们在函数中加上一句 打印语句，看看返回的 <code>b</code>是什么结果，可以看到已经得到了加密后的结果了。【图2-11】</p><p><img src="http://tc.xianyucoder.cn/blog20190903225123.png" alt="图2-10"></p><p><img src="http://tc.xianyucoder.cn/blog20190903225307.png" alt="图2-11"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这次主要把如何扣一个简单的加密算法做了详解，这里包含了基础的JS知识，或许看不明白为什么是复制这些代码而不是其他的，这里我建议可以适当补充一些JS基础语法的知识。等到下次有类似的加密算法时，你可以自己做出判断复制扣取哪些，这样学的更快。</p><p>JS逆向学习的文章每一篇都是很简单的案例，希望看完可以自己动手扣一遍。</p><p>每天一题，头发掉的更快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;XX-街登陆密码加密&quot;&gt;&lt;a href=&quot;#XX-街登陆密码加密&quot; class=&quot;headerlink&quot; title=&quot;XX 街登陆密码加密&quot;&gt;&lt;/a&gt;XX 街登陆密码加密&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/categories/js%E9%80%86%E5%90%91/"/>
    
    
      <category term="js逆向" scheme="http://www.xianyucoder.cn/tags/js%E9%80%86%E5%90%91/"/>
    
      <category term="密码加密" scheme="http://www.xianyucoder.cn/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Apk打包流程梳理和加载流程学习</title>
    <link href="http://www.xianyucoder.cn/2019/08/26/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <id>http://www.xianyucoder.cn/2019/08/26/安卓逆向学习-apk打包流程梳理/</id>
    <published>2019-08-26T10:39:35.000Z</published>
    <updated>2019-08-26T11:15:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>想要学习逆向必须先熟悉APP编译的流程。</p><h4 id="安卓加载流程"><a href="#安卓加载流程" class="headerlink" title="安卓加载流程"></a>安卓加载流程</h4><p>java 代码 – &gt; 加载布局文件 –&gt; 资源文件</p><p>资料参考链接：</p><blockquote><p><a href="https://juejin.im/entry/58b78d1b61ff4b006cd47e5b" target="_blank" rel="noopener">https://juejin.im/entry/58b78d1b61ff4b006cd47e5b</a></p></blockquote><h4 id="新版官网示意图"><a href="#新版官网示意图" class="headerlink" title="新版官网示意图"></a>新版官网示意图</h4><p><img src="http://tc.xianyucoder.cn/blog005MnFO1gy1g5z0anjgm1j30qe0to7d6.png" alt></p><ol><li>编译器将您的源代码转换成 DEX（Dalvik Executable) 文件（其中包括运行在 Android 设备上的字节码），将所有其他内容转换成已编译资源。</li><li>APK 打包器将 DEX 文件和已编译资源合并成单个 APK。不过，必须先签署 APK，才能将应用安装并部署到 Android 设备上。</li><li>APK 打包器使用调试或发布密钥库签署您的 APK：<ol><li>如果您构建的是调试版本的应用（即专用于测试和分析的应用），打包器会使用调试密钥库签署您的应用。Android Studio 自动使用调试密钥库配置新项目。</li><li>如果您构建的是打算向外发布的发布版本应用，打包器会使用发布密钥库签署您的应用。要创建发布密钥库，请阅读在 Android Studio 中签署您的应用</li></ol></li><li>在生成最终 APK 之前，打包器会使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.android.com%2Fstudio%2Fcommand-line%2Fzipalign.html%3Fhl%3Dzh-cn" target="_blank" rel="noopener">zipalign</a> 工具对应用进行优化，减少其在设备上运行时的内存占用。</li></ol><h4 id="旧版官网示意图"><a href="#旧版官网示意图" class="headerlink" title="旧版官网示意图"></a>旧版官网示意图</h4><p><img src="http://tc.xianyucoder.cn/blog20190826083149.png" alt="安卓体系结构"></p><p><img src="http://tc.xianyucoder.cn/blog005MnFO1gy1g5z0cv4i8zj30ew0oiafg.png" alt></p><ol><li>通过aapt打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样）</li><li>处理.aidl文件，生成对应的Java接口文件</li><li>通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件</li><li>通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex</li><li>通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk</li><li>通过Jarsigner工具，对上面的apk进行debug或release签名</li><li>通过zipalign工具，将签名后的apk进行对齐处理。</li></ol><p>安卓项目的文件结构与安卓apk的文件结构存在着一一对应的关系。</p><p>安卓应用开发的本质是：将源代码和各种资源文件编译整合成一个apk。</p><p>安卓逆向的本质是：想办法将apk转化为源代码和资源文件。 </p><p>简单来说，apk就是一个带有签名的zip格式的压缩包，签名为了保护开发者的权益和标识apk。做为android逆向学习的第一步，了解apk的文件结构和生成过程是很有必要的。为了提升apk的安全性能，现在很多安卓应用程序的核心代码都采用NDK开发，所以生成的apk中会多出一个lib文件夹用于存放so文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想要学习逆向必须先熟悉APP编译的流程。&lt;/p&gt;
&lt;h4 id=&quot;安卓加载流程&quot;&gt;&lt;a href=&quot;#安卓加载流程&quot; class=&quot;headerlink&quot; title=&quot;安卓加载流程&quot;&gt;&lt;/a&gt;安卓加载流程&lt;/h4&gt;&lt;p&gt;java 代码 – &amp;gt; 加载布局文件 –&amp;gt
      
    
    </summary>
    
      <category term="App逆向" scheme="http://www.xianyucoder.cn/categories/App%E9%80%86%E5%90%91/"/>
    
    
      <category term="打包流程" scheme="http://www.xianyucoder.cn/tags/%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    
      <category term="加载流程" scheme="http://www.xianyucoder.cn/tags/%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
    
      <category term="APP编译" scheme="http://www.xianyucoder.cn/tags/APP%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>App逆向实基础学习</title>
    <link href="http://www.xianyucoder.cn/2019/08/26/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A01-%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.xianyucoder.cn/2019/08/26/安卓逆向学习1-逆向基础/</id>
    <published>2019-08-26T10:39:35.000Z</published>
    <updated>2019-08-26T11:19:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="常见加密算法"><a href="#常见加密算法" class="headerlink" title="常见加密算法"></a>常见加密算法</h4><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><ul><li><p>escape</p><ul><li>unescape</li></ul></li><li><p>encodeURIComponent</p><ul><li>decodeURIComponent</li></ul></li><li><p>Base64</p><ol><li>所有的数据都能被编码为只用65个字符就能表示的文本。<br>标准的Base64每行为76个字符，每行末尾添加一个回车换行符(\r\n)。不论每行是否满76个字符，都要添加一个回车换行符。</li><li>65字符：A~Z a~z 0~9 + / =<br>URL Base64算法中，为了安全，会把 + 替换成 - ，把 / 替换成 _<br>= 有时候用 ~ 或 . 代替</li><li>Base64的应用<br>密钥,密文,图片,数据简单加密或者预处理</li><li>Base64编码解码与btoa、atob</li></ol></li><li><p>Hex</p><ol><li>二进制数据最常用的一种表示方式。</li><li>用0-9 a-f 16个字符表示。每个十六进制字符代表4bit。也就是2个十六进制字符代表一个字节。</li><li>在实际应用中，尤其在密钥初始化的时候，一定要分清楚自己传进去的密钥是哪种方式编码的，采用对应方式解析，才能得到正确的结果</li></ol></li></ul><h5 id="单向散列函数-消息摘要算法"><a href="#单向散列函数-消息摘要算法" class="headerlink" title="单向散列函数(消息摘要算法)"></a>单向散列函数(消息摘要算法)</h5><ul><li>不管明文多长，散列后的密文定长</li><li>明文不一样，散列后结果一定不一样</li><li>散列后的密文不可逆</li><li>一般用于校验数据完整性、签名 sign</li><li>由于密文不可逆，所以后台无法还原，也就是说他要验证，会在后台以跟前台一样的方式去重新签名一遍。也就是说他会把源数据和签名后的值一起提交到后台。所以我们要保证在签名时候的数据和提交上去的源数据一致,这种算法特喜欢在内部加入时间戳</li><li>常见算法<ul><li>MD5</li><li>SHA1</li><li>SHA256</li><li>SHA512</li><li>HmacMD5</li><li>HmacSHA1</li><li>HmacSHA256</li></ul></li></ul><h5 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h5><p>加密和解密的过程是可逆的</p><ul><li><p>对称加密算法</p><ul><li>加密/解密使用相同的密钥</li><li>DES 数据加密标准</li><li>3DES    TripleDES    DESede</li><li>AES 高级加密标准<ul><li>根据密钥长度不同又分为AES-128 AES-192 AES-256</li><li>其中AES-192 AES-256在Java中使用需获取无政策限制权限文件</li></ul></li><li>CryptoJS提供ECB,CBC,CFB,OFB,CTR五种模式填充提供NoPadding ZeroPadding Pkcs7(Pkcs5) Iso10126 Iso97971 AnsiX923</li></ul></li><li><p>非对称加密算法</p><ul><li>RSA<ul><li>使用公钥加密，使用私钥解密</li><li>公钥是公开的，私钥保密</li><li>加密处理安全，但是性能极差，单次加密长度有限制<ul><li>pkcs1padding 明文最大字节数为密钥字节数-11密文与密钥等长</li><li>NoPadding    明文最大字节数为密钥字节数     密文与密钥等长</li></ul></li><li>RSA既可用于数据交换，也可用于数据校验</li><li>数据校验通常结合消息摘要算法 MD5withRSA 等</li><li>两种加密算法常见结合套路</li><li>随机生成密钥</li><li>密钥用于AES/DES/3DES加密数据</li><li>RSA对密钥加密</li><li>提交加密后的密钥和加密后的数据给服务器</li></ul></li></ul></li></ul><h4 id="APK基本结构"><a href="#APK基本结构" class="headerlink" title="APK基本结构"></a>APK基本结构</h4><ul><li>lib:各种平台下使用的对应的so文件</li><li>META-INF文件夹:存放工程一些属性文件<ul><li>CERT.RSA:公钥和加密算法描述</li><li>CERT.SF:加密文件，他是使用私钥对摘要明文加密后得到的密文信息,只有使用私钥配对的公钥才能解密该文件</li><li>MANIFEST.MF:程序清单文件，他包含包中所有文件的摘要明文</li></ul></li><li>resource.arsc:资源加密(语言包)对res目录下的资源的一个索引文件,保存了原工程中strings.xml等文件内容<ul><li>drawable:图片</li><li>layout:布局</li><li>menu:菜单</li></ul></li><li>AndriodMainfest.xml:清单文件(图标、界面、权限、入口),安卓工程的基础配置属性文件。</li><li>classes.dex:java代码编译得到的Dalvik VM能直接执行的文件</li><li>assets:资源文件(图片、音频、数据库、网页、配置文件等)</li><li>res:资源文件，需要编译</li></ul><h5 id="res目录与assets目录区别在哪？"><a href="#res目录与assets目录区别在哪？" class="headerlink" title="res目录与assets目录区别在哪？"></a>res目录与assets目录区别在哪？</h5><ul><li>res目录下的资源文件在编译时会自动生成索引文件(R.java),在java代码中用R.xxx.yyy来引用</li><li>asset目录下的资源文件不需要生成索引，在java代码中需要用AssetManager中访问。</li><li>一般来说,除了音频和视频资源(需要放在raw或asset下),用java开发的安卓工程使用到的资源文件都会放到res下；使用c++游戏引擎的资源文件均需要放在asset下。</li></ul><h4 id="JVM、DVM与ART"><a href="#JVM、DVM与ART" class="headerlink" title="JVM、DVM与ART"></a>JVM、DVM与ART</h4><ul><li><p>JVM:Java虚拟机，运行的是.java文件编译后的.class文件</p></li><li><p>DVM:Android4.4及以前使用的都是Dalvik虚拟机，我们知道Apk在打包的过程中会先将java等源码通过javac编译成.class文件，但是我们的Dalvik虚拟机只会执行.dex文件，这个时候dx会将.class文件转换成Dalvik虚拟机执行的.dex文件。Dalvik虚拟机在启动的时候会先将.dex文件转换成快速运行的机器码，又因为65535这个问题，导致我们在应用冷启动的时候有一个合包的过程，最后导致的一个结果就是我们的app启动慢，这就是Dalvik虚拟机的JIT特性。</p><ul><li><p>Dalvik是google专门为安卓操作系统设计的一个虚拟机，经过深度的优化,虽然安卓上的程序是使用java来开发的，但是Dalvik和标准的java虚拟机JVM还是两回事,Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的文件执行格式dex,JVM则执行的是java字节码。</p></li><li><p>通过Dalvik的字节码我们不能直接看到原来的逻辑代码,这是需要借助如Apktool或dex2jar+jd-gui工具来帮助查看,但是注意的是最终我们修改APK需要操作的是.smali文件，而不是导出来的java文件重新编译。</p></li></ul></li><li><p>ART:ART虚拟机是在Android5.0才开始使用的Android虚拟机，ART虚拟机必须要兼容Dalvik虚拟机的特性，但是ART有一个很好的特性AOT（ahead of time），这个特性就是我们在安装APK的时候就将dex直接处理成可直接供ART虚拟机使用的机器码，ART虚拟机将.dex文件转换成可直接运行的.oat文件，ART虚拟机天生支持多dex，所以也不会有一个合包的过程，所以ART虚拟机会很大的提升APP冷启动速度。<br>Xposed hook的是Java代码，所以Xposed不支持5.0以及以上系统。</p></li></ul><h4 id="安卓分区"><a href="#安卓分区" class="headerlink" title="安卓分区"></a>安卓分区</h4><p>Android通常有以下分区（用df 来查看分区情况）</p><ul><li>System分区: 就是我们刷ROM的分区</li><li>Data分区:  分区就是我们装APK的分区</li><li>Catch分区:  是缓存分区</li><li>SDCard分区: 就是挂载的SD卡。</li></ul><p>data分区常见目录：app、system、data、local、misc</p><ol><li>data/data目录<br>存放的是所有APK程序数据的目录，每个APK对就一个自己的Data目录，就是在data/data/目录下，会产生一个跟 Package一样的目录。比如有一个APK,它的包名叫com.test.hello则,在data/data/目录下会有一个 com.test.hello的目录,这个APK只能操作此目录,不能操作其它APK的目录</li><li>data/app目录<br>用户安装的APK放在这里。我们如果把APK放入这个文件夹下面的话，就算安装好了。这就叫静默安装。不用管APK文件里面的lib目录下的库文件，系统会自动帮我们放入调用库</li><li>data/misc目录<br>保存WIFI帐号，VPN设置信息等。比如保存了一个WIFI连接帐号，则此目录下的WIFI目录下面wpa_supplicant.conf可以查看到</li></ol><p>system分区常用目录：app、lib、xbin、bin、media、framework</p><ol><li>system/app目录<br>存放系统自带的APK。将APK放入到System/app目录下，也是静默安装</li><li>system/lib目录<br>存放APK程序用到的库文件</li><li>system/bin目录和system/xbin目录<br>存放的是shell命令</li><li>system/framework目录<br>启用Android系统所用到框架，如一些jar文件</li></ol><p>sd卡目录：/sdcard    /mnt/sdcard</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;常见加密算法&quot;&gt;&lt;a href=&quot;#常见加密算法&quot; class=&quot;headerlink&quot; title=&quot;常见加密算法&quot;&gt;&lt;/a&gt;常见加密算法&lt;/h4&gt;&lt;h5 id=&quot;编码&quot;&gt;&lt;a href=&quot;#编码&quot; class=&quot;headerlink&quot; title=&quot;编码&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="App逆向" scheme="http://www.xianyucoder.cn/categories/App%E9%80%86%E5%90%91/"/>
    
    
      <category term="基础" scheme="http://www.xianyucoder.cn/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="app逆向" scheme="http://www.xianyucoder.cn/tags/app%E9%80%86%E5%90%91/"/>
    
      <category term="编码" scheme="http://www.xianyucoder.cn/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="加密" scheme="http://www.xianyucoder.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="apk基本结构" scheme="http://www.xianyucoder.cn/tags/apk%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>App签名</title>
    <link href="http://www.xianyucoder.cn/2019/08/26/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A01.2-apk%E7%AD%BE%E5%90%8D/"/>
    <id>http://www.xianyucoder.cn/2019/08/26/安卓逆向学习1.2-apk签名/</id>
    <published>2019-08-26T10:39:35.000Z</published>
    <updated>2019-08-26T11:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是签名？"><a href="#什么是签名？" class="headerlink" title="什么是签名？"></a>什么是签名？</h4><p>如果这个问题不是放在Android开发中来问，如果是放在一个普通的版块，我想大家都知道签名的含义。可往往就是将一些生活中常用的术语放在计算机这种专业领域，大家就开始迷惑了。计算机所做的事情，或者说编程语言所做的事情，不正是在尽可能地模拟现实吗？所以，计算机中所说的签名和生活中所说的签名在本质上是一样的，它所起到的作用也是一致的！</p><h4 id="为什么要给Android应用程序签名？"><a href="#为什么要给Android应用程序签名？" class="headerlink" title="为什么要给Android应用程序签名？"></a>为什么要给Android应用程序签名？</h4><p>如果只能用一句简单的话语来回答这个问题的话，我会说：“这是Android系统所要求的”。<br>Android系统要求每一个Android应用程序必须要经过数字签名才能够安装到系统中，也就是说如果一个Android应用程序没有经过数字签名，是没有办法安装到系统中的！Android通过数字签名来标识应用程序的作者和在应用程序之间建立信任关系，不是用来决定最终用户可以安装哪些应用程序。这个数字签名由应用程序的作者完成，并不需要权威的数字证书签名机构认证，它只是用来让应用程序包自我认证的。</p><h4 id="为什么我开发的Android应用程序没有做什么签名也能在模拟器和手机上运行？"><a href="#为什么我开发的Android应用程序没有做什么签名也能在模拟器和手机上运行？" class="headerlink" title="为什么我开发的Android应用程序没有做什么签名也能在模拟器和手机上运行？"></a>为什么我开发的Android应用程序没有做什么签名也能在模拟器和手机上运行？</h4><p>你没有给Android应用程序签名并不代表Android应用程序没有被签名。为了方便我们开发调试程序，ADT会自动的使用debug密钥为应用程序签名。debug密钥？它在哪？debug密钥是一个名为debug.keystore的文件，它的位置：<br>系统盘符:/Documents and Settings/liufeng/.android/debug.keystore</p><p>liufeng对应于你自己的windows操作系统用户名，怎么样，是不是已经找到它了。这也就意味着，如果我们想拥有自己的签名，而不是让ADT帮我们签名的话，我们也要有一个属于自己的密钥文件（*.keystore）。</p><p>如果你以前的程序是采用默认签名的方式（即debug签名），一旦换了新的签名应用将不能覆盖安装，必须将原先的程序卸载掉，才能安装上。因为程序覆盖安装主要检查两点：<br>1）两个程序的入口Activity是否相同。两个程序如果包名不一样，即使其它所有代码完全一样，也不会被视为同一个程序的不同版本；<br>2）两个程序所采用的签名是否相同。如果两个程序所采用的签名不同，即使包名相同，也不会被视为同一个程序的不同版本，不能覆盖安装。<br>另外，可能有人可能会认为反正debug签名的应用程序也能安装使用，那也没有必要自己签名了嘛。千万不要这样想，debug签名的应用程序有这样两个限制，或者说风险：<br>1）debug签名的应用程序不能在Android Market上架销售，它会强制你使用自己的签名；</p><p>2）debug.keystore在不同的机器上所生成的可能都不一样，就意味着如果你换了机器进行apk版本升级，那么将会出现上面那种程序不能覆盖安装的问题。不要小视这个问题，如果你开发的程序只有你自己使用，当然无所谓，卸载再安装就可以了。但要是你的软件有很多使用客户，这就是大问题了，就相当于软件不具备升级功能！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是签名？&quot;&gt;&lt;a href=&quot;#什么是签名？&quot; class=&quot;headerlink&quot; title=&quot;什么是签名？&quot;&gt;&lt;/a&gt;什么是签名？&lt;/h4&gt;&lt;p&gt;如果这个问题不是放在Android开发中来问，如果是放在一个普通的版块，我想大家都知道签名的含义。可往往就是
      
    
    </summary>
    
      <category term="App逆向" scheme="http://www.xianyucoder.cn/categories/App%E9%80%86%E5%90%91/"/>
    
    
      <category term="app逆向" scheme="http://www.xianyucoder.cn/tags/app%E9%80%86%E5%90%91/"/>
    
      <category term="签名" scheme="http://www.xianyucoder.cn/tags/%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>App逆向之smali学习</title>
    <link href="http://www.xianyucoder.cn/2019/08/26/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A02-smali%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.xianyucoder.cn/2019/08/26/安卓逆向学习2-smali语法/</id>
    <published>2019-08-26T10:39:35.000Z</published>
    <updated>2019-08-26T11:17:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="smali文件"><a href="#smali文件" class="headerlink" title="smali文件"></a>smali文件</h4><h5 id="什么是smali文件？"><a href="#什么是smali文件？" class="headerlink" title="什么是smali文件？"></a>什么是smali文件？</h5><p>Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种。dex格式文件的汇编器，反汇编器。其语法是一种宽松式的Jasmin/dedexer语法，而且它实现了.dex格式所有功能（注解，调试信息，线路信息等）</p><p>当我们对APK文件进行反编译后，便会生成此类的文件，小编在此对smali文件进行简要的介绍。其中在Davlik字节码中，寄存器都是32位的，能够支持任何类型，64位类型（Long/Double）用2个寄存器表示；Dalvik字节码有两种类型：原始类型；引用类型（包括对象和数组）</p><ul><li>原始类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">B---byte</span><br><span class="line">C---char</span><br><span class="line">D---double</span><br><span class="line">F---float</span><br><span class="line">I---int</span><br><span class="line">J---long</span><br><span class="line">S---short</span><br><span class="line">V---void</span><br><span class="line">Z---boolean</span><br><span class="line">[XXX---array</span><br><span class="line">Lxxx/yyy---object</span><br></pre></td></tr></table></figure></li></ul><p>这里解析下最后两项，数组的表示方式是:</p><p>在基本类型前加上前中括号“[”，例如int数组和float数组分别表示为：[I、[F；对象的表示则以L作为开头，格式是LpackageName/objectName;（注意必须有个分号跟在最后），例如String对象在smali中为：Ljava/lang/String;，其中java/lang对应java.lang包，String就是定义在该包中的一个对象。</p><p>或许有人问，既然类是用LpackageName/objectName;来表示，那类里面的内部类又如何在smali中引用呢？答案是：LpackageName/objectName$subObjectName;。也就是在内部类前加“$”符号，关于“$”符号更多的规则将在后面谈到。</p><p>方法的定义方法的定义一般为：     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func-Name (Para-Type1Para-Type2Para-Type3...)Return-Type</span><br></pre></td></tr></table></figure><p>注意参数与参数之间没有任何分隔符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. hello ()V --&gt; void hello()</span><br><span class="line"></span><br><span class="line">2. hello (III)Z --&gt; boolean hello(int, int, int)</span><br><span class="line"></span><br><span class="line">3. hello (Z[I[ILjava/lang/String;J)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">--&gt;String hello (boolean, int[], int[], String, long)</span><br></pre></td></tr></table></figure></p><h5 id="Smali基本语法"><a href="#Smali基本语法" class="headerlink" title="Smali基本语法"></a>Smali基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.field private isFlag:z　　定义变量</span><br><span class="line">.method　　方法</span><br><span class="line">.parameter　　方法参数</span><br><span class="line">.prologue　　方法开始</span><br><span class="line">.line 123　　此方法位于第123行</span><br><span class="line">invoke-super　　调用父函数</span><br><span class="line">const/high16  v0, 0x7fo3　　把0x7fo3赋值给v0</span><br><span class="line">invoke-direct　　调用函数</span><br><span class="line">return-void　　函数返回void</span><br><span class="line">.end method　　函数结束</span><br><span class="line">new-instance　　创建实例</span><br><span class="line">iput-object　　对象赋值</span><br><span class="line">iget-object　　调用对象</span><br><span class="line">invoke-static　　调用静态函数</span><br></pre></td></tr></table></figure><h5 id="smali条件分支"><a href="#smali条件分支" class="headerlink" title="smali条件分支"></a>smali条件分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">条件跳转分支：</span><br><span class="line"></span><br><span class="line">&quot;if-eq vA, vB, :cond_**&quot;   如果vA等于vB则跳转到:cond_**</span><br><span class="line">&quot;if-ne vA, vB, :cond_**&quot;   如果vA不等于vB则跳转到:cond_**</span><br><span class="line">&quot;if-lt vA, vB, :cond_**&quot;    如果vA小于vB则跳转到:cond_**</span><br><span class="line">&quot;if-ge vA, vB, :cond_**&quot;   如果vA大于等于vB则跳转到:cond_**</span><br><span class="line">&quot;if-gt vA, vB, :cond_**&quot;   如果vA大于vB则跳转到:cond_**</span><br><span class="line">&quot;if-le vA, vB, :cond_**&quot;    如果vA小于等于vB则跳转到:cond_**</span><br><span class="line">&quot;if-eqz vA, :cond_**&quot;   如果vA等于0则跳转到:cond_**</span><br><span class="line">&quot;if-nez vA, :cond_**&quot;   如果vA不等于0则跳转到:cond_**</span><br><span class="line">&quot;if-ltz vA, :cond_**&quot;    如果vA小于0则跳转到:cond_**</span><br><span class="line">&quot;if-gez vA, :cond_**&quot;   如果vA大于等于0则跳转到:cond_**</span><br><span class="line">&quot;if-gtz vA, :cond_**&quot;   如果vA大于0则跳转到:cond_**</span><br><span class="line">&quot;if-lez vA, :cond_**&quot;    如果vA小于等于0则跳转到:cond_**</span><br></pre></td></tr></table></figure><h4 id="深入smali"><a href="#深入smali" class="headerlink" title="深入smali"></a>深入smali</h4><p>Smali中的包信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.class public Lcom/aaaaa;     </span><br><span class="line">.super Lcom/bbbbb;</span><br><span class="line">.source &quot;ccccc.java&quot;</span><br><span class="line"></span><br><span class="line">它是com.aaaaa这个package下的一个类（第1行）</span><br><span class="line">继承自com.bbbbb这个类（第2行）</span><br><span class="line">这是一个由ccccc.java编译得到的smali文件（第3行）</span><br></pre></td></tr></table></figure></p><p>Smali中的声明</p><p>一般来说在Smali文件中是这个样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># annotations</span><br><span class="line">.annotation system</span><br><span class="line">Ldalvik/annotation/MemberClasses;</span><br><span class="line">value = &#123;Lcom/aaa$qqq;,Lcom/aaa$www;&#125;</span><br><span class="line">.end annotation</span><br></pre></td></tr></table></figure><p>这个声明是内部类的声明：aaa这个类它有两个成员内部类——qqq和www，内部类将在后面小节中会有提及。</p><p>Smali的成员变量</p><p>成员变量格式是:<br>.field public/private [static] [final] varName:&lt;类型&gt;</p><p>对于不同的成员变量也有不同的指令:<br>一般来说，获取的指令有：iget、sget、iget-boolean、sget-boolean、iget-object、sget-object等。</p><p>操作的指令有：iput、sput、iput-boolean、sput-boolean、iput-object、sput-object等。<br>没有“-object”后缀的表示操作的成员变量对象是基本数据类型，带“-object”表示操作的成员变量是对象类型，特别地，boolean类型则使用带“-boolean”的指令操作。</p><p>实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sget-object v0, Lcom/aaa;-&gt;ID:Ljava/lang/String;</span><br></pre></td></tr></table></figure><p>sget-object就是用来获取变量值并保存到紧接着的参数的寄存器中，本例中，它获取ID这个String类型的成员变量并放到v0这个寄存器中。</p><p>注意：前面需要该变量所属的类的类型，后面需要加一个冒号和该成员变量的类型，中间是“-&gt;”表示所属关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iget-object v0, p0, Lcom/aaa;-&gt;view:Lcom/aaa/view;</span><br></pre></td></tr></table></figure><p>可以看到iget-object指令比sget-object多了一个参数，就是该变量所在类的实例，在这里就是p0即“this”。</p><p>获取array的话我们用aget和aget-object，指令使用和上述一致</p><p>put指令的使用和get指令是统一的如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span>/<span class="number">4</span> v3, <span class="number">0x0</span></span><br><span class="line">sput-object v3, Lcom/aaa;-&gt;timer:Lcom/aaa/timer;</span><br></pre></td></tr></table></figure></p><p> 相当于：this.timer= null;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.local v0, args:Landroid/os/Message;</span><br><span class="line">      const/4 v1, 0x12</span><br><span class="line">      iput v1, v0, Landroid/os/Message;-&gt;what:I</span><br></pre></td></tr></table></figure><p> 相当于：args.what = 18;（args是Message的实例）</p><h4 id="寄存器知识"><a href="#寄存器知识" class="headerlink" title="寄存器知识"></a>寄存器知识</h4><p>寄存器是什么意思呢？</p><p>在smali里的所有操作都必须经过寄存器来进行：本地寄存器用v开头数字结尾的符号来表示，如v0、v1、v2、…参数寄存器则使用p开头数字结尾的符号来表示，如p0、p1、p2、…特别注意的是，p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”，p1表示函数的第一个参数，p2代表函数中的第二个参数…而在static函数中p0才对应第一个参数（因为Java的static方法中没有this方法)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const/4 v0, 0x1</span><br><span class="line">iput-boolean v0, p0, Lcom/aaa;-&gt;IsRegistered:Z</span><br></pre></td></tr></table></figure><p>我们来分析一下上面的两句smali代码，首先它使用了v0本地寄存器，并把值0x1存到v0中，然后第二句用iput-boolean这个指令把v0中的值存放到com.aaa.IsRegistered这个成员变量中。<br>即相当于：this.IsRegistered= true;（上面说过，在非static函数中p0代表的是“this”，在这里就是com.aaa实例）。</p><p>####</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;smali文件&quot;&gt;&lt;a href=&quot;#smali文件&quot; class=&quot;headerlink&quot; title=&quot;smali文件&quot;&gt;&lt;/a&gt;smali文件&lt;/h4&gt;&lt;h5 id=&quot;什么是smali文件？&quot;&gt;&lt;a href=&quot;#什么是smali文件？&quot; class=&quot;he
      
    
    </summary>
    
      <category term="App逆向" scheme="http://www.xianyucoder.cn/categories/App%E9%80%86%E5%90%91/"/>
    
    
      <category term="app逆向" scheme="http://www.xianyucoder.cn/tags/app%E9%80%86%E5%90%91/"/>
    
      <category term="smali学习" scheme="http://www.xianyucoder.cn/tags/smali%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>App逆向实战和AndroidKiller简单使用</title>
    <link href="http://www.xianyucoder.cn/2019/08/26/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A05-AndroidKiller%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/"/>
    <id>http://www.xianyucoder.cn/2019/08/26/安卓逆向学习5-AndroidKiller简单使用和实战/</id>
    <published>2019-08-26T10:39:35.000Z</published>
    <updated>2019-08-26T11:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先聊聊为什么学习安卓逆向"><a href="#先聊聊为什么学习安卓逆向" class="headerlink" title="先聊聊为什么学习安卓逆向"></a>先聊聊为什么学习安卓逆向</h4><p>大数据的普及，好像没有一手数据收集能力就要落伍了似得，不少无关开发的岗位都加上需要初级数据采集的能力要求，越来越多的 title 加上 数据 的字眼提升逼格。</p><p>渐渐初级爬虫工程师的饭越来越不好吃，中高级的爬虫的招聘需求也添加上 JS 逆向+ APP 逆向的要求，所以有一手破签逆向的技术也越来越吃香。</p><p>APP逆向其实已经属于安全方面的内容，而我们爬虫工程师要做的其实远没有逆向工程师那么多和精，只要拿到请求中加密参数的加密方法，再用 Python 模拟加密即可。</p><p>为了面包，学习吧。</p><h4 id="学习资源推荐"><a href="#学习资源推荐" class="headerlink" title="学习资源推荐"></a>学习资源推荐</h4><p>关于逆向的前置知识，可以参考之前发过的几篇基础文章，同时咸鱼也推荐下面这些学习资源，希望能帮助你快速入门（伸手党福利？？？）：</p><ul><li>吾爱破解入门教程集合贴：<a href="http://t.cn/Ai8hXHzs" target="_blank" rel="noopener">http://t.cn/Ai8hXHzs</a></li><li>推荐关注的博客：<ul><li>尼古拉斯·赵四：<a href="https://blog.csdn.net/jiangwei0910410003" target="_blank" rel="noopener">https://blog.csdn.net/jiangwei0910410003</a></li><li>鬼哥：<a href="https://blog.csdn.net/guiguzi1110?viewmode=contents" target="_blank" rel="noopener">https://blog.csdn.net/guiguzi1110?viewmode=contents</a></li><li>天天记小本子上的lilac：<a href="https://blog.csdn.net/qq_38851536" target="_blank" rel="noopener">https://blog.csdn.net/qq_38851536</a></li></ul></li><li>推荐逆向书籍：<ul><li>《Android软件安全与逆向分析》</li><li>《Android应用安全防护和逆向分析》</li><li>《JAVA加密与解密的艺术》第二版</li></ul></li><li>推荐关注的公众号：<ul><li>小周码字</li><li>编程美丽</li><li>妄为写代码</li></ul></li></ul><p>其实还有好多好多的资源，请善用搜索。</p><p>以上仅为我的个人推荐，大佬请无视~</p><p>接下来是咸鱼动手跟着做的第一个项目，某个小游戏的付费破解，了解AndriodKiller逆向工具的使用。</p><h4 id="AndriodKiller的简单使用和实战"><a href="#AndriodKiller的简单使用和实战" class="headerlink" title="AndriodKiller的简单使用和实战"></a>AndriodKiller的简单使用和实战</h4><p>在使用这个逆向工具，需要先检查本地的 JAVA 开发环境是否安装。</p><p>命令行下输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version -- 输出JAVA jdk 版本</span><br></pre></td></tr></table></figure><p>如果出现无版本信息输出或其他报错请参照相关博客或后台回复 【逆向环境搭建】获取相关搭建视频。</p><p>接下来是 AndriodKiller 的安装了，在吾爱的网站上提供了相关的 绿色免安装版本，找到软件可以直接点击使用。</p><p>【良心】</p><p>打开界面后是下面这样的：</p><p><img src="http://tc.xianyucoder.cn/blog20190824214643.png" alt></p><p>打开后第一件事是在 AndriodKiller 的配置中配置 jdk 的安装路径之后既可以通过拖入需要反编译的受害者，即可打开进行分析：</p><p>我们这次要完成一款小游戏的付费破解，我们先安装未破解的APP看看能不能通过未破解的APP找到思路。</p><p>通过一番把玩，发现进入支付流程后取消支付会弹出相应提示语，顺着这个思路我们在反编译后的文件中检索一下看能不能找到对应的代码：</p><p><img src="http://tc.xianyucoder.cn/blog20190824224659.png" alt></p><p>我们点击进去看看，发现了我们搜索的字符串：</p><p><img src="http://tc.xianyucoder.cn/blog20190824225026.png" alt></p><p>反编译的代码不太方便查看，我们可以通过查看还原为java代码理解相关的逻辑：</p><p><img src="http://tc.xianyucoder.cn/blog20190824225333.png" alt></p><p>可以看到，还原后的代码中支付失败，支付取消在同一个方法中，支付成功的逻辑为单独一个方法。</p><p>所以我们可以试试通过直接把支付成功的代码逻辑直接替换到支付失败的那个方法中来破解支付</p><p>替换过后查看字符串，发现整个类文件中就只剩下支付成功的方法了。</p><p><img src="http://tc.xianyucoder.cn/blog20190824225922.png" alt></p><p>保存文件之后我们编译一下试试是否成功吧。</p><p><img src="http://tc.xianyucoder.cn/blog20190824230135.png" alt></p><p>编译后，控制台输入如下代表编译成功。</p><p><img src="http://tc.xianyucoder.cn/blog20190824230340.png" alt></p><p>打开 <strong>APP - 商店 </strong>随便购买一个道具，但是不完成支付，点击取消支付，可以看到左上角的道具数量增加了。说明我们的操作是成功的。（为避免破解不成功或误操作导致的扣费，请使用未插卡的机器测试）</p><p><img src="http://tc.xianyucoder.cn/blog20190824231037.png" alt></p><p>OK，到这里我们就完成了第一个安卓APP的逆向破解，当然这个是非常简单的逆向项目。</p><h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h4><ol><li><p>AndriodKiller 并不是万能的，有些项目是没办法反编译成功的，所以需要搭配其他的逆向工具使用</p></li><li><p>AndriodKiller 在第一次导入项目时，会一直卡在<code>反编译成功，xxxx</code>但是没有打开项目，需要收到重启AndriodKiller ，在<code>工程</code>中打开刚刚的项目。</p></li><li><p>AndriodKiller 转化为 java 代码时在 java 代码中是无法编辑的，需要返回到 smali 中修改，所以 smali语法相当关键，需要好好研究不要对 软件自带的 转换功能过多依赖，且在 smali 中修改后要记得 ctrl + s保存，之后再编译。</p></li><li><p>在编译过程中出现报错，报错日志大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">当前 Apktool 使用版本：apktool_2.3.0</span><br><span class="line">正在编译 APK，请稍等...</span><br><span class="line">&gt;I: Using Apktool <span class="number">2.3</span>.0</span><br><span class="line">&gt;I: Smaling smali folder into classes.dex...</span><br><span class="line">&gt;I: Building resources...</span><br><span class="line">&gt;S: WARNING: <span class="function">Could not write <span class="title">to</span> <span class="params">(C:\Users\i\AppData\Local\apktool\framework)</span>, using C:\Users\i\AppData\Local\Temp\ instead...</span></span><br><span class="line"><span class="function">&gt;S: Please be aware <span class="keyword">this</span> is a <span class="keyword">volatile</span> directory and frameworks could go missing, please utilize --frame-path <span class="keyword">if</span> the <span class="keyword">default</span> storage directory is unavailable</span></span><br><span class="line"><span class="function">&gt;W: E:\AndroidKiller_v1.3.1\projects\idm下载\Project\res\values-v23\styles.xml:8: error: Error retrieving parent <span class="keyword">for</span> item: No resource found that matches the given name '@android:style/WindowTitle'.</span></span><br><span class="line"><span class="function">&gt;W: </span></span><br><span class="line"><span class="function">&gt;W: E:\AndroidKiller_v1.3.1\projects\idm下载\Project\res\values-v23\styles.xml:9: error: Error retrieving parent <span class="keyword">for</span> item: No resource found that matches the given name '@android:style/WindowTitleBackground'.</span></span><br><span class="line"><span class="function">&gt;W: </span></span><br><span class="line"><span class="function">&gt;W: E:\AndroidKiller_v1.3.1\projects\idm下载\Project\res\values-v24\styles.xml:7: error: Error retrieving parent <span class="keyword">for</span> item: No resource found that matches the given name '@android:style/Animation.DropDownUp'.</span></span><br><span class="line"><span class="function">&gt;W: </span></span><br><span class="line"><span class="function">&gt;W: E:\AndroidKiller_v1.3.1\projects\idm下载\Project\res\values-v24\styles.xml:8: error: Error retrieving parent <span class="keyword">for</span> item: No resource found that matches the given name '@android:style/Animation.DropDownDown'.</span></span><br><span class="line"><span class="function">&gt;W: </span></span><br><span class="line"><span class="function">&gt;Exception in thread "main" brut.androlib.AndrolibException: brut.androlib.AndrolibException: brut.common.BrutException: could not <span class="title">exec</span> <span class="params">(exit code = <span class="number">1</span>)</span>: [C:\Users\i\AppData\Local\Temp\brut_util_Jar_6839346043621878032.tmp, p, --min-sdk-version, 16, --target-sdk-version, 26, --version-code, 1, --version-name, 1.0, --no-version-vectors, -F, C:\Users\i\AppData\Local\Temp\APKTOOL8354570300607898895.tmp, -0, resources.arsc, -0, arsc, -I, C:\Users\i\AppData\Local\Temp\1.apk, -S, E:\AndroidKiller_v1.3.1\projects\idm下载\Project\res, -M, E:\AndroidKiller_v1.3.1\projects\idm下载\Project\AndroidManifest.xml]</span></span><br><span class="line"><span class="function">&gt;        at brut.androlib.Androlib.<span class="title">buildResourcesFull</span><span class="params">(Androlib.java:<span class="number">485</span>)</span></span></span><br><span class="line"><span class="function">&gt;        at brut.androlib.Androlib.<span class="title">buildResources</span><span class="params">(Androlib.java:<span class="number">419</span>)</span></span></span><br><span class="line"><span class="function">&gt;        at brut.androlib.Androlib.<span class="title">build</span><span class="params">(Androlib.java:<span class="number">318</span>)</span></span></span><br><span class="line"><span class="function">&gt;        at brut.androlib.Androlib.<span class="title">build</span><span class="params">(Androlib.java:<span class="number">270</span>)</span></span></span><br><span class="line"><span class="function">&gt;        at brut.apktool.Main.<span class="title">cmdBuild</span><span class="params">(Main.java:<span class="number">224</span>)</span></span></span><br><span class="line"><span class="function">&gt;        at brut.apktool.Main.<span class="title">main</span><span class="params">(Main.java:<span class="number">75</span>)</span></span></span><br><span class="line"><span class="function">&gt;Caused by: brut.androlib.AndrolibException: brut.common.BrutException: could not <span class="title">exec</span> <span class="params">(exit code = <span class="number">1</span>)</span>: [C:\Users\i\AppData\Local\Temp\brut_util_Jar_6839346043621878032.tmp, p, --min-sdk-version, 16, --target-sdk-version, 26, --version-code, 1, --version-name, 1.0, --no-version-vectors, -F, C:\Users\i\AppData\Local\Temp\APKTOOL8354570300607898895.tmp, -0, resources.arsc, -0, arsc, -I, C:\Users\i\AppData\Local\Temp\1.apk, -S, E:\AndroidKiller_v1.3.1\projects\idm下载\Project\res, -M, E:\AndroidKiller_v1.3.1\projects\idm下载\Project\AndroidManifest.xml]</span></span><br><span class="line"><span class="function">&gt;        at brut.androlib.res.AndrolibResources.<span class="title">aaptPackage</span><span class="params">(AndrolibResources.java:<span class="number">454</span>)</span></span></span><br><span class="line"><span class="function">&gt;        at brut.androlib.Androlib.<span class="title">buildResourcesFull</span><span class="params">(Androlib.java:<span class="number">471</span>)</span></span></span><br><span class="line"><span class="function">&gt;        ... 5 more</span></span><br><span class="line"><span class="function">&gt;Caused by: brut.common.BrutException: could not <span class="title">exec</span> <span class="params">(exit code = <span class="number">1</span>)</span>: [C:\Users\i\AppData\Local\Temp\brut_util_Jar_6839346043621878032.tmp, p, --min-sdk-version, 16, --target-sdk-version, 26, --version-code, 1, --version-name, 1.0, --no-version-vectors, -F, C:\Users\i\AppData\Local\Temp\APKTOOL8354570300607898895.tmp, -0, resources.arsc, -0, arsc, -I, C:\Users\i\AppData\Local\Temp\1.apk, -S, E:\AndroidKiller_v1.3.1\projects\idm下载\Project\res, -M, E:\AndroidKiller_v1.3.1\projects\idm下载\Project\AndroidManifest.xml]</span></span><br><span class="line"><span class="function">&gt;        at brut.util.OS.<span class="title">exec</span><span class="params">(OS.java:<span class="number">95</span>)</span></span></span><br><span class="line"><span class="function">&gt;        at brut.androlib.res.AndrolibResources.<span class="title">aaptPackage</span><span class="params">(AndrolibResources.java:<span class="number">448</span>)</span></span></span><br><span class="line"><span class="function">&gt;        ... 6 more</span></span><br><span class="line"><span class="function">APK 编译失败，无法继续下一步签名!</span></span><br></pre></td></tr></table></figure><p>我的解决方案是：替换 AndriodKiller 目录下 bin\apktool\apktool 中的 ShakaApktool.jar 为更新的版本即可成功编译，签名。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;先聊聊为什么学习安卓逆向&quot;&gt;&lt;a href=&quot;#先聊聊为什么学习安卓逆向&quot; class=&quot;headerlink&quot; title=&quot;先聊聊为什么学习安卓逆向&quot;&gt;&lt;/a&gt;先聊聊为什么学习安卓逆向&lt;/h4&gt;&lt;p&gt;大数据的普及，好像没有一手数据收集能力就要落伍了似得，不少无
      
    
    </summary>
    
      <category term="App逆向" scheme="http://www.xianyucoder.cn/categories/App%E9%80%86%E5%90%91/"/>
    
    
      <category term="app逆向实战" scheme="http://www.xianyucoder.cn/tags/app%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
      <category term="逆向资源" scheme="http://www.xianyucoder.cn/tags/%E9%80%86%E5%90%91%E8%B5%84%E6%BA%90/"/>
    
      <category term="AndroidKiller" scheme="http://www.xianyucoder.cn/tags/AndroidKiller/"/>
    
  </entry>
  
  <entry>
    <title>聪明工作-如何做好文件管理？</title>
    <link href="http://www.xianyucoder.cn/2019/08/26/%E8%81%AA%E6%98%8E%E5%B7%A5%E4%BD%9C-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%9F/"/>
    <id>http://www.xianyucoder.cn/2019/08/26/聪明工作-如何做好文件管理？/</id>
    <published>2019-08-26T10:39:35.000Z</published>
    <updated>2019-08-26T10:59:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><p>文件的「生命周期」 = 新建 + 修改 + 移动 +删除</p><ul><li>桌面文件整理<ul><li>给新建文件好好取个名字<ul><li>时间 + 类型 + 文件内容 + 版本号</li></ul></li><li>做好桌面文件的关联和归档</li><li>合理安排桌面的文件夹</li></ul></li><li>下载目录整理</li></ul><p>推荐工具：Everything，Droplt，Total Commander</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;文件管理&quot;&gt;&lt;a href=&quot;#文件管理&quot; class=&quot;headerlink&quot; title=&quot;文件管理&quot;&gt;&lt;/a&gt;文件管理&lt;/h4&gt;&lt;p&gt;文件的「生命周期」 = 新建 + 修改 + 移动 +删除&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;桌面文件整理&lt;ul&gt;
&lt;li&gt;给新建文件
      
    
    </summary>
    
      <category term="聪明工作" scheme="http://www.xianyucoder.cn/categories/%E8%81%AA%E6%98%8E%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="文件管理" scheme="http://www.xianyucoder.cn/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>聪明工作-如何做好任务管理？</title>
    <link href="http://www.xianyucoder.cn/2019/08/26/%E8%81%AA%E6%98%8E%E5%B7%A5%E4%BD%9C-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%9F/"/>
    <id>http://www.xianyucoder.cn/2019/08/26/聪明工作-如何做好任务管理？/</id>
    <published>2019-08-26T10:39:35.000Z</published>
    <updated>2019-08-26T10:58:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="任务管理就是人生规划"><a href="#任务管理就是人生规划" class="headerlink" title="任务管理就是人生规划"></a>任务管理就是人生规划</h4><ul><li>长期任务（人生规划）<ul><li>健康</li><li>教育</li><li>理财</li></ul></li><li>中期任务（职业规划）<ul><li>实现自我价值</li></ul></li><li>短期任务（周计划，日计划）</li></ul><h4 id="双任务系统"><a href="#双任务系统" class="headerlink" title="双任务系统"></a>双任务系统</h4><ul><li>今天必须做完的事（短期或中期任务）</li><li>对自己很重要的事情（长期任务）</li></ul><h4 id="理解任务管理的体系（LTF体系）"><a href="#理解任务管理的体系（LTF体系）" class="headerlink" title="理解任务管理的体系（LTF体系）"></a>理解任务管理的体系（LTF体系）</h4><ul><li>list</li><li>tag</li><li>filter</li><li>高级任务管理注重的点在与 filter 的使用</li><li>OmniFocus &amp; Todoist</li><li>团队协作：Teambition</li><li>大量数据的任务管理：在线<strong>表格</strong>工具</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;任务管理就是人生规划&quot;&gt;&lt;a href=&quot;#任务管理就是人生规划&quot; class=&quot;headerlink&quot; title=&quot;任务管理就是人生规划&quot;&gt;&lt;/a&gt;任务管理就是人生规划&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;长期任务（人生规划）&lt;ul&gt;
&lt;li&gt;健康&lt;/li&gt;
&lt;li&gt;教
      
    
    </summary>
    
      <category term="聪明工作" scheme="http://www.xianyucoder.cn/categories/%E8%81%AA%E6%98%8E%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="任务管理" scheme="http://www.xianyucoder.cn/tags/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
      <category term="任务管理体系" scheme="http://www.xianyucoder.cn/tags/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB/"/>
    
      <category term="LTF体系" scheme="http://www.xianyucoder.cn/tags/LTF%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>聪明工作-如何做好笔记整理和思维导图？</title>
    <link href="http://www.xianyucoder.cn/2019/08/26/%E8%81%AA%E6%98%8E%E5%B7%A5%E4%BD%9C-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%9F/"/>
    <id>http://www.xianyucoder.cn/2019/08/26/聪明工作-如何做好笔记整理？/</id>
    <published>2019-08-26T10:39:35.000Z</published>
    <updated>2019-08-26T10:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="笔记整理"><a href="#笔记整理" class="headerlink" title="笔记整理"></a>笔记整理</h4><h5 id="了解笔记整理的基本原则"><a href="#了解笔记整理的基本原则" class="headerlink" title="了解笔记整理的基本原则"></a>了解笔记整理的基本原则</h5><ul><li>记重点<ul><li>过于详细的记录反而拉低效率，只记关键字</li></ul></li><li>先收集<ul><li>把笔记变成收集箱，关键字要记成</li></ul></li><li>可回溯<ul><li>记下来的笔记以后要能找到</li></ul></li></ul><h4 id="不同类型笔记工具的优缺"><a href="#不同类型笔记工具的优缺" class="headerlink" title="不同类型笔记工具的优缺"></a>不同类型笔记工具的优缺</h4><ul><li>电子笔记整理更方便，可编辑，已分享</li><li>纸笔更自然</li></ul><h4 id="选择适合自己的笔记APP"><a href="#选择适合自己的笔记APP" class="headerlink" title="选择适合自己的笔记APP"></a>选择适合自己的笔记APP</h4><p>记完笔记推荐使用费曼学习法</p><p><img src="http://tc.xianyucoder.cn/blog20190825235300.png" alt></p><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><h5 id="为什么使用思维导图"><a href="#为什么使用思维导图" class="headerlink" title="为什么使用思维导图"></a>为什么使用思维导图</h5><p>信息接受速度太快，导致「消化不良」</p><ul><li>思维导图的逻辑简单理解</li><li>节约时间和精力</li><li>应用范围很广泛<ul><li>头脑风暴</li><li>书摘</li><li>决策</li><li>商务提案</li><li>目标设定</li></ul></li></ul><h4 id="思维导图的通用技巧"><a href="#思维导图的通用技巧" class="headerlink" title="思维导图的通用技巧"></a>思维导图的通用技巧</h4><p>最重要就是敢记，思维导图就是为了帮助我们整理思路，所以不要怕记错记杂</p><ul><li>内容：多记，速记</li><li>形式：注意结构，清晰简明</li></ul><p>只记关键词，避免整句记录</p><p>自创常用字标签，提高记录速度</p><h4 id="如何选择思维导图"><a href="#如何选择思维导图" class="headerlink" title="如何选择思维导图"></a>如何选择思维导图</h4><ul><li>iThoughtsX</li><li>Xmind</li><li>MindNode（多文件导入导出）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;笔记整理&quot;&gt;&lt;a href=&quot;#笔记整理&quot; class=&quot;headerlink&quot; title=&quot;笔记整理&quot;&gt;&lt;/a&gt;笔记整理&lt;/h4&gt;&lt;h5 id=&quot;了解笔记整理的基本原则&quot;&gt;&lt;a href=&quot;#了解笔记整理的基本原则&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="聪明工作" scheme="http://www.xianyucoder.cn/categories/%E8%81%AA%E6%98%8E%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="笔记整理" scheme="http://www.xianyucoder.cn/tags/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
      <category term="思维导图" scheme="http://www.xianyucoder.cn/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
      <category term="通用技巧" scheme="http://www.xianyucoder.cn/tags/%E9%80%9A%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>
